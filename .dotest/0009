From 5a89054dd6d75dab16b0bb5e9dbf6531e7c6122f Mon Sep 17 00:00:00 2001
From: Armin Weatherwax <Armin.Weatherwax@gmail.com>
Date: Fri, 3 Jul 2009 13:01:51 +0200
Subject: Dale Glass' avatar list with some embellishment from Emerald and Meerkat. /me adds some imprudence by fixing the typing detection, the client detection and the false alarms of the movement detection. Todo: Move the artwork where it belongs, consider the UUID for client detection and provide a web ressource for downloading the client detection xml file.

	new file:   artwork/linden/indra/newview/skins/default/textures/496d7072-7564-656e-6365-20726f636b73.j2c
	new file:   artwork/linden/indra/newview/skins/default/textures/avatar_gone.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/avatar_new.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/avatar_particles.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/avatar_sound.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/avatar_typing.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_blue.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_green.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_orange.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_pink.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_purple.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_red.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/flag_yellow.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/icon_avatar_expand.png
	new file:   artwork/linden/indra/newview/skins/default/textures/info_error.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/info_fetching.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/info_unknown.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/payment_info_charter.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/payment_info_filled.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/payment_info_used.tga
	new file:   artwork/linden/indra/newview/skins/default/textures/slim_icon_16_viewer.tga
	modified:   linden/indra/llaudio/audioengine.h
	modified:   linden/indra/llprimitive/llprimitive.cpp
	modified:   linden/indra/llprimitive/llprimitive.h
	modified:   linden/indra/llui/llscrolllistctrl.cpp
	modified:   linden/indra/llui/llscrolllistctrl.h
	modified:   linden/indra/newview/CMakeLists.txt
	modified:   linden/indra/newview/app_settings/settings.xml
	modified:   linden/indra/newview/llagent.cpp
	modified:   linden/indra/newview/llagent.h
	modified:   linden/indra/newview/llappviewer.cpp
	modified:   linden/indra/newview/llchatbar.cpp
	modified:   linden/indra/newview/llfirstuse.cpp
	modified:   linden/indra/newview/llfirstuse.h
	new file:   linden/indra/newview/llfloateravatarlist.cpp
	new file:   linden/indra/newview/llfloateravatarlist.h
	modified:   linden/indra/newview/llfloaterreporter.cpp
	modified:   linden/indra/newview/llfloaterreporter.h
	modified:   linden/indra/newview/llspatialpartition.cpp
	modified:   linden/indra/newview/llstartup.cpp
	modified:   linden/indra/newview/lltoolbar.cpp
	modified:   linden/indra/newview/lltoolbar.h
	modified:   linden/indra/newview/llviewermenu.cpp
	modified:   linden/indra/newview/llviewermessage.cpp
	modified:   linden/indra/newview/llviewerobject.h
	modified:   linden/indra/newview/llvoavatar.cpp
	modified:   linden/indra/newview/llvoavatar.h
	modified:   linden/indra/newview/llworld.h
	modified:   linden/indra/newview/pipeline.cpp
	modified:   linden/indra/newview/skins/default/xui/en-us/alerts.xml
	new file:   linden/indra/newview/skins/default/xui/en-us/floater_avatar_scanner.xml
	modified:   linden/indra/newview/skins/default/xui/en-us/menu_viewer.xml
	modified:   linden/indra/newview/skins/default/xui/en-us/notify.xml
	modified:   linden/indra/newview/skins/default/xui/en-us/panel_toolbar.xml
---
 .../496d7072-7564-656e-6365-20726f636b73.j2c       |  Bin 0 -> 11873 bytes
 .../newview/skins/default/textures/avatar_gone.tga |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/avatar_new.tga  |  Bin 0 -> 1042 bytes
 .../skins/default/textures/avatar_particles.tga    |  Bin 0 -> 826 bytes
 .../skins/default/textures/avatar_sound.tga        |  Bin 0 -> 1042 bytes
 .../skins/default/textures/avatar_typing.tga       |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_blue.tga   |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_green.tga  |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_orange.tga |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_pink.tga   |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_purple.tga |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_red.tga    |  Bin 0 -> 1042 bytes
 .../newview/skins/default/textures/flag_yellow.tga |  Bin 0 -> 1042 bytes
 .../skins/default/textures/icon_avatar_expand.png  |  Bin 0 -> 392 bytes
 .../newview/skins/default/textures/info_error.tga  |  Bin 0 -> 1042 bytes
 .../skins/default/textures/info_fetching.tga       |  Bin 0 -> 1042 bytes
 .../skins/default/textures/info_unknown.tga        |  Bin 0 -> 1042 bytes
 .../default/textures/payment_info_charter.tga      |  Bin 0 -> 1042 bytes
 .../skins/default/textures/payment_info_filled.tga |  Bin 0 -> 1042 bytes
 .../skins/default/textures/payment_info_used.tga   |  Bin 0 -> 1042 bytes
 .../skins/default/textures/slim_icon_16_viewer.tga |  Bin 0 -> 1042 bytes
 linden/indra/llaudio/audioengine.h                 |    1 +
 linden/indra/llprimitive/llprimitive.cpp           |  219 ++-
 linden/indra/llprimitive/llprimitive.h             |    2 +-
 linden/indra/llui/llscrolllistctrl.cpp             |   30 +-
 linden/indra/llui/llscrolllistctrl.h               |    2 +
 linden/indra/newview/CMakeLists.txt                |    2 +
 linden/indra/newview/app_settings/settings.xml     |  154 ++
 linden/indra/newview/llagent.cpp                   |  119 +-
 linden/indra/newview/llagent.h                     |   14 +
 linden/indra/newview/llappviewer.cpp               |   10 +-
 linden/indra/newview/llchatbar.cpp                 |   34 +-
 linden/indra/newview/llfirstuse.cpp                |   31 +-
 linden/indra/newview/llfirstuse.h                  |    2 +
 linden/indra/newview/llfloateravatarlist.cpp       | 2250 ++++++++++++++++++++
 linden/indra/newview/llfloateravatarlist.h         |  816 +++++++
 linden/indra/newview/llfloaterreporter.cpp         |   15 +-
 linden/indra/newview/llfloaterreporter.h           |    3 +-
 linden/indra/newview/llspatialpartition.cpp        |    2 +-
 linden/indra/newview/llstartup.cpp                 |   23 +-
 linden/indra/newview/lltoolbar.cpp                 |    9 +
 linden/indra/newview/lltoolbar.h                   |    1 +
 linden/indra/newview/llviewermenu.cpp              |   36 +-
 linden/indra/newview/llviewermessage.cpp           |   13 +
 linden/indra/newview/llviewerobject.h              |    2 +
 linden/indra/newview/llvoavatar.cpp                |  251 +++-
 linden/indra/newview/llvoavatar.h                  |    7 +
 linden/indra/newview/llworld.h                     |    2 +-
 linden/indra/newview/pipeline.cpp                  |   46 +
 .../newview/skins/default/xui/en-us/alerts.xml     |  160 ++-
 .../default/xui/en-us/floater_avatar_scanner.xml   |  396 ++++
 .../skins/default/xui/en-us/menu_viewer.xml        |    4 +
 .../newview/skins/default/xui/en-us/notify.xml     |   14 +
 .../skins/default/xui/en-us/panel_toolbar.xml      |    8 +
 54 files changed, 4615 insertions(+), 63 deletions(-)
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/496d7072-7564-656e-6365-20726f636b73.j2c
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/avatar_gone.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/avatar_new.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/avatar_particles.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/avatar_sound.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/avatar_typing.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_blue.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_green.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_orange.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_pink.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_purple.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_red.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/flag_yellow.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/icon_avatar_expand.png
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/info_error.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/info_fetching.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/info_unknown.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/payment_info_charter.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/payment_info_filled.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/payment_info_used.tga
 create mode 100644 artwork/linden/indra/newview/skins/default/textures/slim_icon_16_viewer.tga
 create mode 100644 linden/indra/newview/llfloateravatarlist.cpp
 create mode 100644 linden/indra/newview/llfloateravatarlist.h
 create mode 100644 linden/indra/newview/skins/default/xui/en-us/floater_avatar_scanner.xml

diff --git a/artwork/linden/indra/newview/skins/default/textures/496d7072-7564-656e-6365-20726f636b73.j2c b/artwork/linden/indra/newview/skins/default/textures/496d7072-7564-656e-6365-20726f636b73.j2c
new file mode 100644
index 0000000000000000000000000000000000000000..69c3c60bb80538be8feddd1e5a7bb7e45df896f4
GIT binary patch
literal 11873
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

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/avatar_gone.tga b/artwork/linden/indra/newview/skins/default/textures/avatar_gone.tga
new file mode 100644
index 0000000000000000000000000000000000000000..dacda59abdc69f7b51d89e81d31ea14bb957e2cb
GIT binary patch
literal 1042
zcmXw&U2KzO6vs~o`|1{{F|2OReX%bfAhJl@+DRZW_>~OUmPIF$8OV%=h$4|hFTL>E
z3%t`C6Jz|yE{sA#)IcC46UR0gW8G)htzFx-^lNSR_I-YyUic>eJWrlC|L2_ZJLeH8
zk^euJxTL895KP>$SeV>V+^@uN_@Hct$j(WYWt>N<dAYgeD|rmgsTIVs)I&%W5n_2=
z3z8u#j~*aBuC-W`q^S{OS4-Tk62Ik?q-htd4)>p%feaGeN~<TP@j{XhFX|qdUqkBa
zu7?ja$8!6-RylHN1@Ef{?~C9$i0MBLjWr9VvH5y<c1iEZCdIOgc_4SjkzHlWslEH*
zfXB)|=YbuS87iGQT)Wb?l-{SlV-Zge#$B!VwEP|p<dCTVGLc@8*LqU%eJusMyE|rG
z{vu_6^(_pYS*O<ZH+5C(oE!;q^)^(t|7>}@n8vzU(^-FQv&h4*@ts1h?<Cp50Y5+f
z8Zqf@?E4c~=TA@D!^iTBsdtJkuHJ$Ay*~O+K!@_UWhP5j)L$tUedpl$o;YW9z3~@D
z>oRNl^Wi^ADg$Hc?HdUrWz%@NFiwe?ab_i={su>uS1u;(nhs1&4GauLnD)iV6Cz<P
zF*^ZoA20AsRRq@)mg!YK)v{_8dmAeHmEx&Ow%OenwL6<LT)7-D{!q}^tYfoDXc<QP
zAJ}zI-J|NsG`&Z)a0!}8<{j&by0++l5BqS}n*H%;lBs(XH2>{DFly#zbGp^~Cn&u2
z?kW}TAU$4iOWZufUmCI~eY$KVb5xmJxIp2D?{zAoaCZv(%BO3L3?{h!2jsRfUw;Qj
zUWP-R&>{)ubxu<m9PZj*Ld^}B;WKdQ^BKPR3C?~Pp}j3hyYl$pT!FFQR{8A9<n{~4
zC>(B0=e^ajxIc_T+aigSGHAWE(bV=Y!|%ZPkFeXi17`Q0$ELLdyq-934*BSPDaye^
z(9m!#th4UWvQ&A=q_<=>L3vZ>jg396(EA3w{yygPC(7lb#o(x}16cdo^VTlsQg&_w
zNs<&F<2y5%gwjiuXL4~#XnWnIGaGKnX5D)Ftg6A0qg;wI)(KBCaZ_hq<CZ89jU6q%
r*^10o@s8q~$}1I0g34tbQyS3xR5GVhR&qDBQ1nVF<QL+_cZ>W7{Lra@

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/avatar_new.tga b/artwork/linden/indra/newview/skins/default/textures/avatar_new.tga
new file mode 100644
index 0000000000000000000000000000000000000000..854b70c326416a41f68f2c858d6d2f6b8a37e53d
GIT binary patch
literal 1042
zcmX|=?N6Ik7{*UqhJM^Xpc1lg#+Ug~vuT`wxEX_CY%yCD;-XSOgds2X1t_KLp#?;@
zfw0+@$>`_?fmi~A4XE45SacY=cBRlUAQW4$wD3HAd(P!4%e=pw`<$HLeXet#>kuL(
z&tpH?PtsllKoI8l?E)#u+>Kz0lg7zo5yS(edPK+qY<(5tJ}<T<Ay6sXmkNk%q!L79
zgv}*M_I~hhQqXle{aAChI!l+el-ZCK$<kzo57!@bzf*TWol*H-dH_-B4vokd&p1{i
zw8xWq!6T{YQ|2C099cj4%a^E`&_i>t4L?2VMCC0dvfDn1zftn$lcTB+KNY}}Fy)gv
z_B5}?)=61^dEWcFqp@l`2kuc18t2TA+f*nStxjkkcA&-G7cUws!>bi9g;<RoKLiqD
z8a%$Igd1#oIj8e8f8m4*ngt`iozdacPzh@6dXx@m#pA|8T5`7z8dp2yBj4jS`CH4G
zRT=5d=%$26loVaAP@S?Ci_Pm-kw2}$i4i&E_EPG_7Ih;meq*gpoV0xrFSa*8@3?_1
z{c(Dz?)6$Hgw##!NadF*J<6F@aEq5{@uV6RqjmVsR0(Imjffb-#Zgn@>+3a%T%#QI
ze|A81w-JXm2Nzda&o?2YRQKt^=9M9;ePF=3Sq>}s2Lfx(UWkA|V{l_fEFIRMXuKT8
z4Rbt0`!3Jkm+T@URrEH-EdEinIy%LM=|;G)L<7$&Fn%et1TQw|4|g~ek1JuAzkp2L
z2k|AwC)oXKuj)LewIR{8b|cm}Wk__)8WT+e?UZSwJSeTR*3*)SLgWt@quKQvl=c>y
z&3)uqV7wneqW%5n+J?Wn(eJ-WEv`XanYW;I>O6H|5k72#yVH)s@iHhL8mNA;hn~26
zCh@W1n8FE47NQ$c{iG?a;JRwH_sJ;i{@I9iVGsu9o#v!}=DMMsJrAv;8y9?5RLz{D
zZ>x^1<ad3Z=0Z5>A*pj~nKX@c<>~+URj{m#Vd&r67zm7r=EZBYYyJv)eKu<L+fY7U
zkL>0gzN)W2=Rv@g^gY4WGyev#O}Lv~d0!3IuC+OOFdVprsnC5)`0vFm%QmPc4fJ&9
znRSI#o%=Yvy2nPMkZtq-`&i-*ddZK|##i(s7ZseP#o1(O;kDNc!BVq&p`iP$Qr)jV
zuto#V&IM$#u<!!UG=%tF8MY$Hb%{5+Mz&Z_MZ{%0;H5qUrB4x(`5?;XLMzEVvZ%1j
J{tdsE{|8(&#l!#r

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/avatar_particles.tga b/artwork/linden/indra/newview/skins/default/textures/avatar_particles.tga
new file mode 100644
index 0000000000000000000000000000000000000000..0e544efaeb4df3626e7b13be1a8f8508c436e6e9
GIT binary patch
literal 826
zcmZWo&r6h16n*oJ`3nhGf^fyz^dY24Y2d=mEF2vQ1GSi<C_$JOxt_J7feZfuMcla3
zg<Aau;UWg4?Tye62E<lL8;!L5I_JK55;Sn$+#lz>d)|99&b7Pn>2#eg*SesRxE3tq
z!2QESnt=@BZeSHS0m=&~I)~_H6^rvrs1>+J%5L5B(1?s;n^(!>j%1XK%j`QV)-x8H
z8IxyKp3SI~ROR)V%Fd}tP)*KNYR4)czNl<Jy|xtDCeRl@g4stS^J&oRUa5?vDlzb&
z?#KP(XR;O~Z>~%Nag|Y=VqpIzhL(T=&`pO2f%J|O<~b|RDCUw+Gb)1^RPp1T_I_P|
z3l(X7o@UWfqn4aF?K%7$(qT_&R=Ee)+ZQTZIDhSj%F!tlb)f8E{zkZ_%8JU}#^LgG
zJ)1VE%t1VW>h0g!dus{&tnqDuK|aIiCZ5MUo3|H!Fq-ju5{znhg-eKE0)I%yFn>vK
zxb_R@MRf%3;^(|kAmTT+Pp%!t9V$a*m5Du-jc;(6q!E@+z#z~So-VN;NDoT>C(-bk
z?3;wy{(rrQliEn|8m7xke_G_<nq8*ZMMicoraAIn(Mqo2J!6FM-<X+tJocnGU3@e-
MP%0E3j@@y80lF55?EnA(

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/avatar_sound.tga b/artwork/linden/indra/newview/skins/default/textures/avatar_sound.tga
new file mode 100644
index 0000000000000000000000000000000000000000..ec5dacbf006c26bed04da90425e7a07594e15e0c
GIT binary patch
literal 1042
zcmX|AZ%kWN6u*71kbT_O&BPcJ6B9m}%w>R^Q5hj@(RIvXVNEfml=80y3TqWsm=j8Y
zu40tP*j&^P8fU~TOZ+gC%^0K3I6oj74cj8x>3|hl+P-)1yZ7h4W%!blob%58o%6fr
z{th7;+4**p-Q=-d;2_Gl0Lc^zWQ#K!0AexNsgWnjmu6!IbW8gAQp`ven<Qh(oVAS?
zD#sYvq=u$2l!9b44-{6#I-{@~vPVwlwxq4*OLez<%d@$Bai<r#wfGAO1;fq5(bFqd
z-q0n!jDZr_!=^Ya-jaM&4}3?AocTZQpUj%x<n@rQ-q4uK<u14zTL7cfpD^U~4Ur=o
zlJiS@{%t>0c6;x=97uE^S{d+n9&k0et3%;aRSiweE8YDeKKNP~ot*)2CQ9`;m_agY
zD68AIFxpZ9t7h-=k1Kaj7VZtBH`Gu2`UZtR5QNv?jbqN^aJM$X)8?XT7DWL)lZVz^
zdoxh?h*44hM2;SR<~Dz7&)5FZ*cr^eGs|PK5#jT<(-Vy@JYQRj6Ruapt9~yw3zobi
z>}}4Qf%<)ma8_ZU>V-=^j%U}!(~mFxc6vC5`S}a*`C5hRq)QxYaPXrqI^gy8z~31H
zmA$)~Z>+T(%-3`{8S0)};!Bd#fhYe&-NF0j_;{ROzWf=F$Kx0|Gm1zw%KQ2U#2aT5
z=m_?pXu;OuUbx%)@@7rgOW`>3E0*Ql>JOzw&Hl7CJ)Ok0YhU5|^&7Zy<tn{!@e(Gd
zrdVnwh0s7ZWf0`SeQ06-4{edIzu|HI5p6hpCwS74#^L=-ze{}a-Pu{BQg6w7yw5-W
z<WsyiH-`^D`T(aQeZru{k{<s`gA7H!_qR6vT;VyIW<i$)kMF8KnLJl5Yg8tasp^Tu
zRApjvdU<B%ZT7{&=a?8D12dI=EU8;+zqblK8v1D{5h<Yk$ojW;O-71EL%pwEz0;!9
z-Q4-}+Wh>*kvGqd6=Op&A*8-3w)8Emmvpec3fu7Dm%i6~zIk**>RREX**NFr4}C40
z&Dr8(3FqX*xiqJc{KYPgLb(Z(m>jynpfLekJ`cO#(1hFzAq253rW<BqhmW4k<<#z!
z_DSxjO>k>F7EGPdq_)*;)W6b<9{L*NrrZ;?$5uJzMY~`!Z%CfXRDF{YC|(rWe+y%u
A6#xJL

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/avatar_typing.tga b/artwork/linden/indra/newview/skins/default/textures/avatar_typing.tga
new file mode 100644
index 0000000000000000000000000000000000000000..d04242d05ca47484f2e4091d0e872f3f739cd5c7
GIT binary patch
literal 1042
zcmYjQ%Wf1$6s_*DBNDMdh-DVYi~K>vHzY!^g;>VI#t4IiBE*gu6f5%B9>5_MFDnTs
zm;oZ=fK6Bs38KIzu;3w?$e5AAIAI<=Jw4q${j9o&TRkzNrK?-7bL-qwr-d-Z+P6V$
z5S!Nli2#rVah4!cakgc9jpriedCbAtAVnrX#u^4l-{UndB`FdpBS4bVSgBNoPk2ve
zc$gr3fL8*<^*&frw%@MlOU_Cpaco3@$#@~x&JhVnC73f~+vAKADf41sf7k5jwpZ6i
z1_uywea7j~{iTZQD6W$-uOwxD8JCXteWY9~EQ_1@zVX#ZQ#gHcXY0(!?n8iMqEXho
zJL!LIV!l5~k<02U+d#@%rhHc%2_!Y++|bvHsJ*6VH_of;$9jVK@4p$+XJg0Jd{{>q
zT2n-xQ5-+K>F4A7E>E85#p#J|6n`AV{FO0o87wO#ltmBc3YZ$*{_N7^fi9%~8E7S@
zN4hsx{B~r=Z1eA%5>XR~Sglk;f#%y1{#{v;u45_0K826|MDf_37c)Qfe+(HhcPTD@
zci@wUlY<h?=Y*(1t?Fv(t-J(+I-y!Zqx2Z|@>7Ca24Wj`riL+>@7@AeYuor}rm+9h
z2dDbEl?EKUMy~Z1WUT;|B|`Zhp!@`|o+@W`ff*@z@9J6H%lCa@`I>vP^TN^I&37mI
zdC#Y+(?Z3v;9GAHS4)K25>(|mlF9<rE6a+Iq<62Jz#qd~zpTaj?Ltu;J-B{utS@E&
zIU!K@Jb2zJ0(Tj4vqYY~NDXU|qOi_(cj>Qdqqsk@{c}eK2Bh{F>p#3}-dVWKbY8Ir
zq2hOx9DE(q(o#k|_UouTzJ;H@-TiWAe4vv>Zoj=>6Vv&98-F?4b9HuPZ*qOC7r&10
zpkm=Gb*a#kP9N{V<*{!0`>DNYacJkA>HMM3phD)J<bqbr_k;ZxaMqzUW&bGlTNX{7
z+3Otby$;oK+y4*yn6biZ1%?mgEY_nMKs4Bc0k5+ZB4B^88?yh$jghm1%<rZhBIm^D
Fcn3-g2t)t?

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_blue.tga b/artwork/linden/indra/newview/skins/default/textures/flag_blue.tga
new file mode 100644
index 0000000000000000000000000000000000000000..e61e7a9121ed0279344d9b19aa87229f0b0c2b63
GIT binary patch
literal 1042
zcmXw2e@v8h82{dT_Xq2ba;<f%(K0t%;MNbPtUt;YRwT0x$~6fYv=LHTVL>HWE|7#0
z#zgC|4gG`jNDLXGlT(C5GlV#?Q@8`6k{eudc;0b$@4fH)eLg*R<-2|MeD}WJ&+|O*
z=lMKBDB|9;Oe_=2Q$SG#Pz5M1AXQ=LF+qGLNC7~^7>{i%J80e725VvSfmK^}-|vq@
zz+mt<$fyYvOF)nj6}k}-lKGPP1X3arBBOXOUbnfiW>*)|-ud!#Uo^=#G2cvpMRJ}5
zlKK9RagGK<Wjvi<WxVmDTVMZepO&7#yZawK$xq%7@Hs$a3SddxMN~wf3Fexk2246b
zOYk?Bdp5PYX>;pUq!(1H^E%AnzW%HCmq2XJgfL79^1C1`G~>V5izP}BtMe=C*Hm^<
zp?#88<n6(9nD0?SA5EP7WcA_xudR1RZ1<`Cbwc*lKA?70zj^_|1p(a<p-4pJ?5KY&
z{k?<upwoxcyzlgW&mGoWGXqP?Rog?CG1v~cj{<+%RfKK0=*U1@%M+U0Su{-Jj<;(n
zx3@g}-1>O#zLRprRy&m)IQb%=bB>r8u!(M5JEqNFc}e%4dW%ArYXR>GV0Hi){)WOG
z8`Qg(YPFy2-=prd+jy$NiAS?O-V-O{{teNyGqn!C?Fi!frxbD)Kwc^%j5TQRwgC&B
zK=`<XuM<6;4O+$iQOauh9oFoRhIwv6V{IIp*5%&pdVB`sKR}+zgW8*8$e{{}>7xYS
zIcT#NF*EAGF9VH{Z9B)P#5swT`Bexoe=a1&uZ5ZE6Lw`BBaJWyN{n!SQQR1==Kg!R
zz6;?+H*R@4FmbIxD=Ilp#l2pvEoY5<>^s0Tl)ozFicMU=m`$qQ7A)R4#Q)z;m^}~p
zU0AsN2hB|%p;^xtC@yWowsSYJvZTq#{BZ9hgMKK7w{KL2c0G6;bx&%j5pt=DZR=cz
zzn!I^sbfHBf=A^e%)6+y>9lMbokGU@`{>yXU%flU-sK{!W7xdNdzAEWjJ*Yy=(AZV
ze)cn9@;brOOgDZ`lSkTfFro%gTHk?}vzt#PJkE1uKtv5K5iMXp%fO_$vEr4~rpmMv
zw%X;>j{0YA*~(w&Dab82l=Wsip3m9eomo_q-Rt*?xYQM$k~@^bURR<?Uqa{s_D2K?
b@2SE$%`l`T4%O_!ZSx3p%V1bqmbl)(-}J|O

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_green.tga b/artwork/linden/indra/newview/skins/default/textures/flag_green.tga
new file mode 100644
index 0000000000000000000000000000000000000000..cefd399e3b42142522493f0af019bb92e8ffe562
GIT binary patch
literal 1042
zcmXw2ZA_b06uz`ww)l(aALp-`85d&~bn_!l9pa`2G8i&c<SS4HTihm)EMrjW0NtR1
zbOuVsu(WGNWJ00iqnf3T&SB=3AX5hdQ)w1HDqU@%rF8Fm?|r;)2{$=8A35hd=bU>E
zAu6)*;z>N&wuJ&}00fK)5`05fY%x3Ho=iDzQWu-$_<Uo_uH4U_2uO$%zAD9cJ)W<}
zbHNd_Z^Wt~fxKMOfH%zd*o$WzJRw`B_eBIIi{WZw{#0N^1qols*d%O9euXp&e?C{w
z5-pQ*;#b%4LXLhYAPWo{!x1%5HMkrHDiP2}f+Qu5NbC6&9P(UN#nii(CRv8%E)w!;
zsh_Ur6*wd!u>J)!i$eZS$U;}&4+d0{(3$8ZDnq?HOV_%q(vJMDX>89qi`i8LTj^CM
zsfNV4<O@l1>c9cKWqlp*2|25!XnC5ik%uDh!V1)BpBO&ancs-xy&i1MYi91*urfQ*
zyQD5}P4U|PvfxXPgSPtncsI4vLVJOn+xa1Dyme}A*!N9mNpsoFZTqrt$mqu71sy1?
zzr1H{c}b1XJgL?t{qA0}v9ez)S&_Sp*Z$TdTNef}7`%m!Kh3Ceo`B`{MS9lOj*6iv
z{!FC{Pp6jG#bzvetk)gva@_0S4fAGt^o|}?f1G2D_b;N|^BwE~2Zlp^?1u#>n)*7S
zwO+^DZIgH^rEE;ZEC00RRPp}O%JyUI3y+l+{#=F9F+FM~jc9w&jjlxp?DK=%I(`LT
zkMtnZ)QiJIe!3&O76CEar7+ukx@7l`6OHdj4G*j+9dAPU?FQ(^jkqw^O?$jf{{7+z
z@0z*_(^x<Do-soE?JR%oNE=3H#9xd0D~>+<*r$f%WwWmzmf#IoyrZ!BT<8s7V}m{y
zANGuJ>x7**-|c2eb@ja3>BXyB6FpFD+B&wfs`~t7IyqL8GI8We4l*tK=ze1Y^rNRy
z?W%|E?|%FkxdW$k6Fu?`WM6J!Z4=AbTi(uhW}GXS1{Hf3Boq<VlGuf?vP%q`Jn)l`
znm<OZ%YeRzZf=}0vy;En(L=UMJ{S!n-C$wc(`p80Aa)kmtn?9;Vse}!FNT)L;VSJ*
zc{Q2AqVt(@K}!bm&gTYR$<$tZC%pr29&GGSE^bKs$v>xxFsk8<tHnKN@Q4v<Wi2+B
gP{>arVX@zWR=G@8;3YCbf`?TBaTEV|WA~^2A1QsbL;wH)

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_orange.tga b/artwork/linden/indra/newview/skins/default/textures/flag_orange.tga
new file mode 100644
index 0000000000000000000000000000000000000000..6e73c31b596cb8c3e04932afedc5c9eaf14287bc
GIT binary patch
literal 1042
zcmXw2e@s(X6uy0JGX7fpV_7n?MPp`Am;G`fa|X#Gnb}an2u76Z)TvXTON<k1q2ky;
zVKAK0&FP#}BgIU>46M_rn`6lkDd|kA1sY)5VJq^hls;Zx@4eqnOMJ=6NzS|9_nmvr
zcNtUIvu_@o#}=gMfT98{Oc8-#D&kC|9D`(_48+*NHQT;_amPu#u&M6EVzd4EU>sEE
z$^RTMXcRMqR|%sLK9;~s!poS#g~nFyI)t1v9;8>aV$nvMH87jR8;IWsXr_b)q)vP)
z#q=Dvpfi#a7ucJdZ9M0!H@>R=rk-XlZx1E(Wqj@&!jy#pI@J;wL?~iLp$mh~WwNiu
z8xHh;?C{BTXFW*URG|eqjL+~7IGC6EAH=xfU()&yFnNN4CGJDorl<r<FD$Kn*VZhz
zI=ynf`6~>}By<uX*(<gyjc@GtPJU>QY3W}Kie(4?(z1>?JG*HHkLk>l2v}~(;nhpG
zRH3AG0I8en;<tuWh46HDD6iLyca{34@r{2BwfDJJe-FqmAHo_-pI(0EX-|_|U!QAl
zKJ{EiaV)#xwn+W-xZH8Xu`)a{sl+Frvezod+N&Qxx1K`0_{4<#@;BhLA84Kcs=G94
z{vo98Z&UTcW8Elf8{u!;FJnpW?y9-|!4}!?)mW}!s^U82mPQpNzd}}ZLI268qiq=I
z@I$op0c9-%`X}eSa_vbs=6_VwlfZMDUFyDH@;<0hhY$4v`4>3yo#56R5KTTQZx0Fd
z_;p<RJBS*WKbrU5AJWnh#F7mMF-mg{Oo5s9G%kIoO!}<Exb+g}=JT_$1FkSG`c$|d
z3JgC4Tz95WcXdR6Z|?=UySWb;MfK?H*T_FGFw2iAE6QZ&(Oxbb9^l;FI4<7j(nX7O
z2Y`M*r0Wjk@f$#vwF8yc0$8!Lmgnp|`cm)oxRO!&t@5h9zs2;krn72Vnnjgsn?U_)
za18+6QQ#^W+Ywe}fuln-+#N&acBfpn?(jAmk10f+i^OS{QJr==Mg9*MJz=obwh_7K
z`UK9$BC`BXAq(pv3K|9zTv%`KLR#L}F2W~$BuQ2z-vsC_fc+DU7&D8Gz5M?6*30?D
z?xEbze-C8ubzXUEqwRF&XI3mPsBF*LRh4~nbd+(-kghO+BLz_?7^k;H9D{ONd4yRd
a1g<<GuZ5`BNy?9@*GHT@KBk!@)&2(?oy0Bx

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_pink.tga b/artwork/linden/indra/newview/skins/default/textures/flag_pink.tga
new file mode 100644
index 0000000000000000000000000000000000000000..ccf52b9a4091037244e30051c065702b7169b5d4
GIT binary patch
literal 1042
zcmYLIe@v8R9RJ>XU~F#8t-4jqP3w=68tB~mxmIbb<)+KQ>NrYG&E~C@x|I!&k{@cJ
zFi9J7K(Z2ZN}(n?rzFr8A~`lENg_K)E;<hGj=OvB-h1Bnc|Lt#sP%52z3=;czn{<d
z=R>5?f6oG1K#OuxkeV(Pr3A>7AOK`BQi}f}DUJ-e3O9Y7>-FQ_^|gne^n8{Z%CH}E
zY~Q4kj-;s^y750>@_CxI3<zxo1}*iL;U#}RmigL{=l1Ok>a%<Y^PL<kOR>MLWk9DH
z73R2t#J^|uJO7<hYgN;rxuUvL<ax@@PT27+i#d{_DU;%crKK&&9Lc#$Tk9TEvfYHk
z#`2=FKi+H}R_>-7c)Vn{F)rYo<J%gn6=A=Kbbxzc=Y&9#!1Y7IX_%m=JUgqODLtju
z9s6A^bXVf;Z2VbYI-EUtv~k{OwA~dkzM;RYW(pd01*dxuWjk}H!=Tmg?|pU2+k3F(
z)E&4=YRrL2Xsqw#SXyf~da<9s4l#}!0w<wb@~^A%`Qzf^8qptZ#9Ln$x7ROu^aD|}
z=NIX8AHas{W6$fMX(y(_R8RU@v_f28i%f4}1b26E*2h_^o4Z;8+<6vas069HqRZI(
zT|_RfJdcM8y}O~52AI@9qhBOGMlAjb<Sow({@e(e*asoLWsOUWt~4^=$JL3gS1sRH
z0X%o)H{7?{+s78N`_({~*Is+V3fMIS3X>Rm4b}u}nQc(UMPTXzaJwZUyK9Hir3VL;
z`^Ql{QtU&5_ahnuopAk-*OiM~_#BA62kY<6Dl`1y6jCSCh<8hb`hgoQL0qZ0DK>9E
zgAE;{DA-nmU&nZ6fWyDADyL(9rUx}#x1Ud11&pSs0%w@H3XJr`)$q|IM)pf=|ELq&
zy2kLp`cJJD-r5Jd^-1ku{&}s6LT$CVVc{cP?x2J^w=#^IULEQ*>y0pmVBsgI2JZi%
zzDX=Au2%)Gm%V!%nJn15Z1OBKJkz<Ibs`9=zkfmvdMAL+Fi;NBxd^CxV+7ZxfUUcF
z@$#DL4r9)rcTSNdguQ!N_TGu{khA=S#)m5x|J;7SH5NGX*udDng658OuT=O~ZrO#W
zJyq>5ZY*DQAsD3DxDr_=^c=oFnvR66LrA1F=oW+L9An*S2J81F7;L|ivgXBr?0*0$
CM$cjZ

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_purple.tga b/artwork/linden/indra/newview/skins/default/textures/flag_purple.tga
new file mode 100644
index 0000000000000000000000000000000000000000..7c5671999ffb4f4f776656f4c07d9d984f2bde45
GIT binary patch
literal 1042
zcmYjQTWnNC7@pl0WAudt!-LU4^r0GpMiK>VctS{s*ai~1T_~1IfRvEJ1F4`}%1uM9
z5ZkH=Lf3Y!QOea_T1&G{Y%JZfr4;A|H}tZ*1yZ}+N;zluT;|Mt{%0w~lYE((GynI`
zKi_;mV@~$$o6F|1g)aighJX`h1`HM$cm@vIW0J7olifA*N*XZl)0*nH-4!oQ=(KOg
z(H<cy!{@}ed9!?JuPw{Tg<!cQU*Y5Wzwv%W06DJm&mO4H`B?_|3p%(X4U^eOfiq5d
zbt#yXR%X7WxEyP}_vFf|Klvi}VgKa+&QHOxd0A;1Q_vkMG+Og)MVQPK7BeZ=yM+ht
zt*;xh3hVA-@up*1!l2s3Z2bz2Q*?(X1T9n79E|JF@1_#}or3)*KK%Tm*!oLEE^vQ|
zm_c#U=1bO7-0)M+#=4oiMfJRE?Y9W6uQA$ooc;@wPxVyNU>|KdxGHyh4fb7(;}v(6
zb@N|33&IJQj@t#^5E>_erldeX(a^4=d#?}Yww>a=C$5B(7y37}SGAt`;I(yP=aC@Z
z+*L1^Z}Y4$VK{_2&ARiy^W*YkK5;ZC?;r9b<-G;8Q@$PpICo!IN3Ut>v7p&k-h!VS
zqSkw5ek|GIIj%{A>epER=7vg~9+`pf5tND!=#?R$evqRz4&2dz(3FMn6DXHQP<?g)
ztAFSdZ{+R0`Rwh(1wU>W+T0j}F9~>V0LO1hoEea2TT~*d$%(!Zndlmp4})W3Pvsvd
zZcSK=TpqyIkhG2D`Enxbd_(X~5H~E<BORvdy#uv9#t~JeGWHK1h9VdU^vl&dPoeP2
zuw1^c7V!jFnzS8R<$HN-<FB1KACm}-Lh%m)w^P84X<#r3eK;Xzdg5ZT^O1Cw)}ris
z0&kU6S}V36dUY@jXUmT7o!9fc7t}Q!9Ls_hmNtvD>k@E2LK;p1QL1vB5Yo{Vh{?k(
zqsS?#!s|r`w~z==Jwtvnw6udxWeE!o@)H})|5~O`c2W*g;@V?jc-n-o)Q8?Ac>Xt+
zFu&OIyPx7`b!3KVzX#^ne#HZYHSe#U-?aN=bK{=ccy~n;510SOOWj|b&E0wci(REx
zbBoH>43me2VK}AW)T_3isAs5$?3{{DBk2RX*QTk?X|NgcY%lfaxJ0&|qW>n?fAyi>
AF#rGn

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_red.tga b/artwork/linden/indra/newview/skins/default/textures/flag_red.tga
new file mode 100644
index 0000000000000000000000000000000000000000..2cc6fcc58472ab01c30f9c67a52c489c8450d0e0
GIT binary patch
literal 1042
zcmYLIe@v8h82{dTY*BwS`opD(n<myEiV6}|c~%!1(nh93^E^(l+-?k6RKSQs2Mz(9
z)i_va&Oss&1V&o2RtnWzp+LoCz~C_PMA*TdaCh&I@B97q+%faro;~09{XU=Pc|Py+
zc^H$}{U?e=v9*!lT!P9O6u}_CfMw%+*{k$zLwbJQx&tj(X{&c`upWN&PWX;6&>1vt
zfJ_!7y#4^MQ4Hro3X<Qn|0uTCkKm=!@A0Iitmu{;iX#kkBh`zzUlWiipEq>(e;=Xx
ziSHfeJHH&)%+<Z>`n`v`!}W!>92e?Eg#k*~GlYACQH5gQLN~~SPuS@g-PJHIGEWU-
zy|r9+a~L6(`=8)`cH>^aFiAXSiF=Ux`TMSyEzvnZXCL7=T8gV*E$I}t<}nd%slvGb
z0neC(!80*&qYLrRyXBQDT>6?-6Y>k@*1i$?7c-P&(gXIEy>d(JzG~PzZ{mq8r*_39
zB;p+6E+xjRSIZj})U@cR{UIQq?g2KN{zUTXDfOVm+uzbAGBZACYmnmY%GRpi^+$Gn
zA*>aRn|$*=N%zgO#C1#Ewe6aEzzQvU_o65-1lqcQU;g5#uM=W_h9c+XEvjZ)H|*!;
z_;Y1Fc<SAQM|gP7f<2RTy(+hadrK=JY&iks=R$n;In=Wq0=+}P#XlDGj>`%PYQ|N2
z)0{}HyN2kubNfRx(}?5Rv@_dZOj2D(8i5@-LA;Zx@!~_!o4X(e3Ey)8IQ_K`4(F(U
zuX9jjcTFL7&!<=*{OlswLoZjvJsyRTkG=x3iotCKP;v`BX!_QV>jS_LRXW=|jnZTP
zs9TH9i@YBvVEXVFhTK8Y4-AjJUL6^;8hwT5JbHOMaQr*6Cco$-+_ioU16Mtwvvpq7
z)&-IA$t5^?C-CgPkNJ-LidDmRA({3#q*tDHb!<!atMLy*U%`SRd$$iKjsjPH16(AE
zVK>A#zd~f4xUARo&mkeFQpBY>vTu++{P)1TGK_ZuL5Z}(=4r0OOA1R_Gbsv+rqMp&
z702r#-bjL;Y8k_M50F{YiP$vf#hVl_$T;bJDM0%}`4oB|n{^x0QyZd9DXm?ml%FQe
z=1aGdH=n$)F}>pCmiNo>nzf|+O>6bGpKni-PGw0JdW6mq2|>Ej{o&p5sD5cig+#k1
a{j0!uTN9x@GtMl)=#ddIwHV&Ji2neU`LSLA

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/flag_yellow.tga b/artwork/linden/indra/newview/skins/default/textures/flag_yellow.tga
new file mode 100644
index 0000000000000000000000000000000000000000..64dbac91e36acb430200ac4db43c88219a945d9e
GIT binary patch
literal 1042
zcmYjQYfPI}7(Oj*A;uW?&uC&6mkhj2W84DE7Inf8>f$BpHXW;*Wn;-M&KM$_P6$lA
zj-?TAfpse&%EpjwNY#xB1b3@SkO`GdV63GUN=vWb^_=r~zE79<B~QMS_kEw|ee<5@
z5Mm{_zFd+^mgY#{77dgD%70J^1tSVz0U%-^_t<td++OC=a_!Df9<Wz0nPo=Y;7}rq
zS`9j3TrokR5?#bplh3m_1zBDG9*UYq*(23wS$^rkw`Nq6FZ5~FtsejTTa7a{dvmk@
z3j0B2ooh^9Ti?&}wp5)72~CKeCNzzJi~gV%iE@&X1lP=)^JnQoXZg#O<4?N%c-lR}
z^IoY@gJxdvgvND|4@t;oDWS;?U65EbN)i$lQ3Y8LwU2JB{J5ajLpQhj>9Wm-ctAJm
zn8|;s%^S*V`GFDx4IbR~SsxtkbBf?)3oUC%=&o_p6|dOcL>*uK$(Gsc>F<$$XEX98
zZ63LHXda(l<v1Jy_J)BwPEK;tbdBxy4$BiafBWLV*C+b#t?NLMdxS07^by<sZu9Es
ze8Q?MERgc9^RfMb3}1C|8pXajl={MGyqSbIp2Qo$AiwL^VXX4cX!+j^p!n1{U0M4h
z&wu9iDzRVles{EgH&ih?$6pvz@z})(U;j&t?Hx~2XCO(t!x`EiO!KC{RjlvxqwuH?
z8@?Rn%WZou8+$Uav-MlocJCkhwkhDD^8r>c7{S)zICBP6{a93D$KwfnFg=UPkvX=m
z-i!U6F<!9oZ3usnq^emRE$thg@90&_uInheFvo3IqV%=VIGQ6mzE7y=O=NguAdISO
zGkj%D8!9_zc*!0od=m-7C)Rykr|;g<(UYl~O0(J<D&C)z@p(|<C!-4Mjmf-!KE<6k
zrcplT$Nh&I@lN+N);K=YpWS)n&f!eda@6BlTzdRWa;fVQ$l*bd8ZW!AdlF@rCea+0
z;A6mm40O!{uO9n})n5*y!0u*wwi?G((Lb$$NIJ4rof`9)p6*q|n`ynm_FV|#=LqAD
zu?TVoC-7j$Ao>!(wl{}({&Poq#LBF~pXNP)8h$oBNXb-EvsAR7d)#)ylX|$bhdt49
znr>=npDo;Rz_qrl0);PDpDo!{_tZc%LekI|iT5hJ#!bIz8aLjQ6{<vJ8Dt?X^bH^D
T0z&^UG4BMB<4?tn`o;eMumH^i

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/icon_avatar_expand.png b/artwork/linden/indra/newview/skins/default/textures/icon_avatar_expand.png
new file mode 100644
index 0000000000000000000000000000000000000000..b8716a78b4fcf29ac0e58a586c15e402b573109c
GIT binary patch
literal 392
zcmV;30eAk1P)<h*8VUda018P+L{b0%02lxO02c@b0000HA&)Hp000?uMObuGZ)S9N
zVRB^vL1b@YWgtmyVP|DhWnpA_ami&o0003iNkl<Zc-q94I}XAy42JEhBLny0CBX_)
zXU@>G^bE{Qh>-yy4#2>M;08?WCTU19!A;Uu2uo2Fr~Q7%PTe8^5C}#@2nq}lMGkU-
zrqCF%BqoY3J4xKgyNK{-Ei;kQQ=3oa_pM2+)Ge$8u)bn@0l1&4xl}XPhsqJ$b_v#|
z;N0?M7CabUfeP+`n}{UA%6Z_{Mw1z}7wBmJ70|iWIrim$IG%RfL7fPPAND(Jb&7l~
zAO_yJ2E}S!4r?KJ)O!$<!d3!RdtebubqI;18uZmaYT)@m0nf~FRreg%ATg@uXaX>c
z_QtYBxbS`kz4?3oxWQX&@!2dn@8vgFJM>%{umS3k87g|x^N)3hVZW9X1Lq<VToU;b
m2*J6Ccbzfu*MAjH0R{k3^+O9S@#D$>0000<MNUMnLSTY9!=z{c

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/info_error.tga b/artwork/linden/indra/newview/skins/default/textures/info_error.tga
new file mode 100644
index 0000000000000000000000000000000000000000..d5d71ad95250db886b20d0c4a22e601e71b1caa1
GIT binary patch
literal 1042
zcmXw1OKe+36dgMPu|i$2>xM2sR3Ib-J3y?cVAB;yY>;4439&;W;xANzDpg4UH7Z?@
zwvJON^(S^*$Hs}>%2CpM<TOr<o3HJ@xc)qU5+{D|`SpF~9_AT3($Q$<&N=tYy_YdJ
zd%8}sQ|!g(2z)@ZECztJ+O7V6=4!6-!BG0-rJs`etCtq^H-?vcFaH?R-nx|Oz4Fbn
za&~ZDfBpM}ar*P(Dksh?z@-z|WH5Bbd*k}`_eWE9rA78a6XdIL3LXI-Nk^;;gzH_T
zI-qMSHJtxyG2rAqQ51ID=RX&o3TnCRI!5m9VtlcPk*aN9kPZ6iL7l&MYmq)(DcOVa
zF@BSQcYjGWFMR8J&EVYaXoUSfxxBYS%5jHhq!zvoE@5Qn1Q$yxzN~;g%o{XVGWe~A
ziNS<~cZTyns5Y2M<Z}42NVwf;)al?rqP4A({pY<L{#cVRQd00mPQeR9v$)vQFuH46
zAKy%wZ(oT%zb$ySfMr_)p{YQtr>T(2Wvu7-u(VaCvH2{G7djX%18)u`@q70OpLsI)
z?pmM=Q7>>X?(n(oj!cKzy56H|O~&4S5!*$HLaTWiy0<}|#|Fk~9G<d)%X3-$e097j
zJi7$nCHMl|H4}}rdzxk+9v<PbR6=2Yhjv;Dc{2O-SN;)F+`?tw9_C90T)8pPB#~EK
zIeg)PSZpTRQdJd=W)rP?1@&@~s?9^BA3lQT!7jW~9mD<%3bhKn9&f{`87%7iceG;h
zSVQe;kQ*}OY8m?vH~IGF2C~^aybD?UdN+%)xkVhxZG<N#9RCcq!5pshmv|!HR5gX<
zMh!hpfzi{58zu>lD7Cv-C|0n#z00cyRZQL-@BH_F+x?WEm`$`zQ-@_e5uyGPAyFZM
zXpz`qf|~{!ato7_fws64eWQMU+vY5hNTe&3GDJf07G#(vEK^k0a%6-GEU3pv*jV47
zKw!$_<mIA=0&dH;Svs9QJDW&k|H*CgYPAAge<HL<$XV1q?m#LPD6_hP=}_o?!0$gT
z6rH(qnSv{Jrt3OezQ6Qra(3>MzvJ=gWHPxWJkd-%W<_VBYmqyV+jk<7b5p@!f8H(2
n>d&po?PtXNI2vxXtMp@zo&%?^wt(>JydC%-OmO>gad!O+Age5*

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/info_fetching.tga b/artwork/linden/indra/newview/skins/default/textures/info_fetching.tga
new file mode 100644
index 0000000000000000000000000000000000000000..d9faa4014fe458ce8b9ba4206fdff60fe80bdc61
GIT binary patch
literal 1042
zcmZWoIZLBa6#X*Ql>UVI8x~?=B^DMUDYUV$)W*g}5mBQM(b$A&A>xLpxG%vaVu&C{
zjS)B86*t^*MSb_oJ#P}3VIEw*_a672d)~R{bDSSea-}#a&aa;UoR5zWhu^QSFGob|
zp5M>U&+l_?ZmwixWC-*AjzqpIap!7oZie6Q7oX23`T6<C$;pv|f&$aj)FhRamB`M{
zmaMESq^GBwWUtQ7PPDeRqOGkB?d|R0xu>VcFn?xdMp{~0WMN^!a32T+%+%DBxZQ3^
zO-(h-?e6Zz%E}6EZ*TGP@`AUwH@UjH!o<Xcgu`JoHZ~?zRaH`5U2S@Mdu4WZ7I}Gj
zl9rYxddA+~9$sHxvAw-5Yin!R-`__?MFqLY!NGyl*VnVZ)YQ}%#lZ6NG8!5hjA~->
z9v&Vn#^&ZGSWmpVx;mMgo0HSiQz<Pi6}_{XC=Vzm`uh5$u&@vV0|R(|eum~@YikQT
zJ3H9j-L+iEZE<lC9UUDgDJhZi@^b0#?<W^1rlICTLqm9ce8k1Yh3(7w<Ktud2IYuo
zG>Y-@akIL*ig-K@tq1Fiii(h#nTe5+5j;IT;pXNBM@L7tj$EigS63Gr8yhh^JS>BQ
zgCHM|$0KEBWl~&RtnJ~9j*eQ*@9yq!c6Mgpad~-(lamuHEiFOy$Nc;}yk4)=*4FCC
z|M-iw>Nl6p2I@atUte2YHa0fESYKa9Boe{&^fXjQi>saxV+{T3O8Sodb>8;<<iI`g
z829)0I6OSG9L~?rt+&`W8N>(%gYy3V4ieM*|CaWH@)Yu;&vbp)bFUt=+?c0}o+cLe
zNZf(=u~>|r=5?~3|BNdX3d!W;q;NLWjb6}xHuxTTg*vd7vtvyH!`4#|^)oT3m5>iZ
TXAWvhebj55p{-SJ|MdS2^Pwt<

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/info_unknown.tga b/artwork/linden/indra/newview/skins/default/textures/info_unknown.tga
new file mode 100644
index 0000000000000000000000000000000000000000..b04e4b064d1966d9443d8a902b30f2b6062405ab
GIT binary patch
literal 1042
zcmXw2>rb0i7(Xu^**@+saMS3&pqXF%v>4-}QGvvLFzkaH7l~+=nJJ9v=!77GV+d?G
zCWDTGj)ZQ2wA@<QN(+?UsI*+#Le~~rdQ0E8yqELyyr?I6@;v9{{GR9c+z2Tm|DV(3
zG&y?;06EGE#R-aHW^=L_JIQnre*}^SisRr3&;G<xQjz)>sRUvAM3&jA;7C#LoUF=@
zm0PO+;0^Qj^EY*0oZIfLdQ0f6I+y;f>P_EZ&D-_2F1~XXR3dUg<nj!gQSmuZ#S`#h
zZu0)k(w>U<qW%#r@NyQ2dV$SN<d<jR7`r3(e*0;#t>VJR5aL8B6gZW~F*Xw>6CKs1
z!%bI?@_(CgxH<vb;}#g&FJrj5Og24k#I|Ev-nZ&7eC>R$t@8a(0D<8JE*XuI@%}rn
zOm=*Eurt+zyk`<N{ZDv!qa2I+W~@zg;*s_;^tUS!nCQa6i$UnLm%?qeAHIfzoXUYb
zx!-alxniK$Gh@E17Nb9w!`OWlNIHR(pBg*9R*VfLvZ190A;&cJn(it6_3t(yr`9~D
zdHS$zQ}Qn&wK$+yIxApozl1-VKEs-!6N9bSaku7zV(Yph&vt!<xuIsH?DNpwF4;QH
z9ZAj7v;Hi?PR0759@g#(*!yZQ-CYeNR)Dw%&j%VYqAgPlt>t*u@j0-uE9u)Sd1NT#
zpWxPvLn0z>xb#|O`9U?tn#*D8{Q*JyUyxEEAiGT?<^ej{Q47<(S|GAT4R^0e;4`du
zhr}~Cx{1&V4H-LS*U&d~q3?SZH-y#2IoMa9Gnxf@xH3aWTd!huv<=u_R%Ut{1CaIz
z<U<m1nHzAhj+}E04*e}y`WqSKB?Z{zsgm?#zF!ObAHUF?caA2O4f4{XpX(s+5=a>m
zbePWsZR5L$IiUp1g+*NxyvAONgpbAALg>W^EV}O?1g0ScUDPu8>z>=t_bTL=I@204
z9VM|1TbU4a@JI!aa7|%zK`%RvIy(M)JKR$P5d1U9t()L8>4d<N=_4_Fa6GrN{O|k&
zA_+McO5<)zn8wzj#J!MW9+rknmLopU-3>&nPh-2bCnc<?Btt>=c&ZWDuBjXV%1PNc
zNo~8%WOvr;qArVX-?PA{{kC+}Z3%>(=DLX2`a1ak;xbHH<WJ_9AAy1srQ<!)ppaxe
f%`%??^O@(Ms6A5O4mpTvm2(m3(Fssy)0E~P<*)yN

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/payment_info_charter.tga b/artwork/linden/indra/newview/skins/default/textures/payment_info_charter.tga
new file mode 100644
index 0000000000000000000000000000000000000000..6205da7b422ae8c62991254b3cd1ffa553ea8b95
GIT binary patch
literal 1042
zcmXw2TTEO<7@oagFuveR6BA+)wUr8O<06u<U|XWuYV0LVnpz(kdPz+aC9(R@#Kf5R
zV2n>zAH>Fowpi2X+FA-M6lKe@3+uAwvKL@41=he>_U!GjXU}pj^EtDPlYE)^zxn_9
zuS1BL{J-i*9cid70i;+mEcpV6(=*c(Ve({FvJ?PQ8K}|ak_qh0K%8-yn|@e1b>Ne0
zwN*|^6N!TGJC3eveudo1$=!Ej-=r#48#CwcuY>Hmy3kvHHBs2{x!Z^sT%THivN^}>
zHHHe~&JE1RZ9%F(>s&?SowdqyHx_^1(Kq*PbALi^{&8M??fRPD__en*U*YyLiz!36
zy-Z;e4OmX!^ZRT;2?zZmE(EhU=@xKsU>zN<B5i-57#*%M_I&3{hc(mydG<!i3`%+I
zHUF}AdWPn1bWP{b9hB)IcN(1&TSnW2O82=6X#PD#?Smp(e+q;GRsTG{oCR8$y#X?-
z!O}At`{KaEG~NqS&F;>iWn>c#f3D-zK|yaH+JIwRGVJ{!=e;b<2CIukRqmTiq$Kj8
zC-wB3gAu_oTTtJQsMz;V#EWAh>W4FU#g#Eyhc~eIj}<ib`L#=bJ$_+Wq$I{{lL|~%
zCKI)<yM>fJn4?FMGVGzE(KMB#4el&`ek_ZZM>E(zx{3WG8N4x;qqge->GVLP{`)j6
zeKN@V(XEv|a|$}5igqlvg|27`O^+C+Sl;6q`jShaJMRnFH6)^aqJrJGmW{nP!_vEd
z=j*y>R->KayxtZ!jH5}7o=ukNJMnF_getHF^62ykdh28nEnXEiw~WrQg5EZ;iRRmD
z*!@dV{MZwGrgu7e_9K7d=4Za8=oR0Rbj17E=uQESn1<tzSU;xnusslPW^z+K_v>W*
z{BOa#A2=hIPTpSFnP)ZNVEree4wBGdy&PEi>d<`NaIiX@S(0(oCm4qZ7yG?TZ;R<j
zY+qJEmQ<Lw0dp19u<~B$40j5!p75`Uj@dkpg|~5dWU=z8C-&5WjOsiyJuCN_V^An8
z3fs#tcrVS`wnkQ&-0NFD<?so*Jy50>XVPDW7*}Lqvr_#_Pi&aXV&I$(gYlXLYNa|8
z|F9XmIGu{W<;&)rB|h)$4m!b;zr$p9=1|z30TZqMCpJ%-Qsr4r<nnl^^|*KA#0K}P
Rrx~wUp>h8_R_>=l{sWKf(98e;

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/payment_info_filled.tga b/artwork/linden/indra/newview/skins/default/textures/payment_info_filled.tga
new file mode 100644
index 0000000000000000000000000000000000000000..65e6196924ffe851fde7e1326b99f3a9db89bd14
GIT binary patch
literal 1042
zcmXw2OK($G5Wd&2=#rnnk}W@gKf$U}7gbdW#D)qas05X|DWa$gL_`-w3aSL+rQ+b&
zapE|!Ya2U;T-%9ELU6!N{J2i+*iQV&eVlvdV~!n;G@5f}=9~A?G@thEoYBr`XTJlW
z30L|cps71>tV^;r7o@wAbxKZSozJoDv5h_9KDIy2<QwbR7M{y`TL*+D*_X#SkLA(>
z%b?qqtuVR}Liy20qml1jHoLV^+@NIQEeXa%5^2P<IT>2~ACcuG7Nc>@&IS<-1dvIm
zsoidCsbmr_U%Wsl7~K3^+J@`cWSTXs7zTZ;RAC9pt|rIjB2JDh<nvfsTB4j`j79#}
z{~=@KCkDsFsWZ%TxQrpXy*=#g?qINA$DrGx!(LwwM;03amSs)w{ux>;*QJns$_A#;
zp8FjLU7_L3_b`J$BKPJFY8wS~_B$|}2TW}=n|ofpVL}pUE<8_#YME5rkD)tg_^$%X
zzet2Hqdxrux`AsbZ-2sWwSj0f#`T6U9}3BIG6lzWX)ZKR>x~j81RSRSK={c$dLE3+
zg{2rxKYD=n!gUmi8}K|AtyYVA2M45TF{?FI2Sp=MDl{kfBjYc`;{kfS(xs=d7Vb_h
z1H~y6wknKmQarXy!Qc$Nne`))h`|#MBJ*KdZ&kQ&Kshr-51+ikg<BDvzdVg|7jNM>
z^&8f<YH%Du?Zc7W9}cNL?4#X3<nSKiiwknQ(~+?Iz=yx(=g6P%Ke|of$2V#5-<yQu
zKa|WCIoH0d1a5e(XFtjQ^Gh^)|7XSzkou59wYf(Y&)>CqZjJ+CTNp7P2oD1_PjO7W
zPLBrMqa&W%(Wna{Ec81a7@3T>TdVzQ?lp2|y=j=Ws$uSadB0OG8RbeTw^=G1wQ^~7
zduwy`6Vqm~uv#o+jkUG>%4&Yyh{O`txQ#lI)JW|*;gnFEcbk`Lyz{K*U6&dp?>yUa
z;=0Q=Lq+5N2F6OABx#Dk|AmO}O!9=rZ|SjaqL)&#59#9=%HP<h%7f$Z|MHj=ht7@D
RzvZItEK~9my~A%?{|YJnOeFvS

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/payment_info_used.tga b/artwork/linden/indra/newview/skins/default/textures/payment_info_used.tga
new file mode 100644
index 0000000000000000000000000000000000000000..817e182d47c8d45c34777ddb920e6a603f4da350
GIT binary patch
literal 1042
zcmXw&-A|iU9LG-?EQTBBA7J9e5_jc=iQcOhdPR&5m@t=YC@@_>*ucWvXag%PD~f{_
zXeFiey$u~uQ(jyHN!cpSjb&nMrD*9O%<|qB+VVW-d_Ar6Nlu<~o+sb$@Ao_Td<iKc
z|39b5De~G&Q6$I?j!2dElef+r&n=hh&wj9uG+EDpWC4i?kuV4ZA}a<!z|V!Zh+>E+
zN$_uVn#SU*?&itQt+n{l-H^L5Qjxu4tbVhmtNQdYC`k($LK*kS`yflexDUk%zKZ`s
zoP6VwpXu^-isSJ~dfC=Qn<rawPFsnK!!>hNsteZ-kt)g{Lw4!&LVe1(2L)jQN+O7n
z?rG(a_SXTly07EAr5~s^G)7x}9e97B42`}PeAs_>wOm>GZhddvnSE@NG@mcQ{gS*F
z&3*l=tqv(<vof*o7Y+15E1TN)L9=3D%|Eu$8e1JTZCcUuK#g*B<xHijs=wma`O{lC
zAW`lm^C(PxfdLFG4>Ci<Buc#<(5;xLVZ{zh$SHPt6=)f6!8}{Q=rc2}c&_C>wO+<M
z>avEn<?p@GJ}rl0Q7syyHh7PIqWbVCI_GYqZ($g6w*nIpH*Wj7X|3TR=8o=RIz10<
z$bf3YXY?a&b?Nty2XD0Tn*GbeFvlF!9JNF4Rbup!i-iz@a!LX3#ss=&J5Zy!1kc7S
z)C+e|p{`OqMUcd?LmW%4*Hsg}*)ER)_B98!h21QMJ$lor#P3)|&rA;{H}9guD`#Ih
zzebtjV_X`nEskUN1ZUx7I+K#@W1m<S&6y$p5VMEe?2#B2V%VpK$1c|AAEt(&NpQv|
z@P)gH)>|8LA*_-=uqF|*G|y8>o~hrqo)SmEmel%&;0#YPb9fxG85QLBR4}gD=wM_7
zuJjbGH#gwgSo_fq5=8>n<v=9~A;mdmWLtbrTuaWRE}&=jzg@6wI-y$~Wmi4z!q`6!
z*5;SdMoSBtHPV;2uuDV+3FVv%>;>1{?@4S~V)I+mcjh%1i`b7n$vNo$G}2r5)sT8R
zgqxPm(nHSB0g`!^iwZn*9p&{iEGOZ!NOm&Y#OimX`xkZ08XL!8a0E?uDZ20WzQTDf
z^qQX;y!RJ*Ae83whP*z1CuIHL88Q59O?CNt&^{}JJ}_DuO>GqA{gLA<NqHuDK6&r-
om`S+4pv&zY6C4)yCBa-oqI+V<r~==X2KF8n{&Vd~Wd6(Fzy2=AdjJ3c

literal 0
HcmV?d00001

diff --git a/artwork/linden/indra/newview/skins/default/textures/slim_icon_16_viewer.tga b/artwork/linden/indra/newview/skins/default/textures/slim_icon_16_viewer.tga
new file mode 100644
index 0000000000000000000000000000000000000000..2e76043124c6411a9e791e04481e8b0627ed65be
GIT binary patch
literal 1042
zcmZ`&X-pGa6fVZZEm3*@d`3f{iP30Go=ZY}1Y?ZGv_CX9LRbn~mKZSVb77ShOH0MJ
zAT3)f5Q(BtC=wr1<AR`Qg;Y^dLE?s1;m*u$XQopq1n}G%;x8xpGI!2B-*>h-BGFRO
z{IgQDQWO@pVs36u)IEHKSVI7d0jr{-qM~nib~LzujE-S1;$6@CdKC(VR1BAE07N8&
zkO+bbU|0nBTOyI{ecapa@Nmd~yXR^^TX9s#GbReQ&WZ`%PfxpE^f}YgQ)9rF2$5(Z
zE65=tB4T5|%h|;WRN&^l+KD`40+(Zm#d)RiR9<NUm1~rWnXHR3tj$p=aNzWO;F<HF
z>_9Y-mlB0luLfT{aXe}aoYu<N?2EDVxl4&uVZ~vjt~x@UuRKfxkg_}p<r?FtvlkBG
zTU}R#k&kbNfV+kWtn+Y`kgb!7d0kBgZE039WeuljttFMx)TGcw)r#O*Uw@3QZBgU8
zmSRt#DaFeQC=ebI{tr>u;N>WPj$SHe3r$CmrCEt@-nVdfdK-PVJ7(_M{|4@Xv&Gld
zXZP70X0M^{1eH~Ch(VswfK<FkDvl0nkj_EDY(cpkK~PFpn@+dht>jpqnVFrPnHwB&
zPF6H#VMq$fOGerH7(9+Y2X;%vyLSFkV39w+ERj>0k`VDKwx-d#%jtBFt6f0YJ#D&n
z1{2%7LXJN64+=_9AUSBQsdTY5m1*oSuulg%{aQ;Jqp_qg<W6Ny8vj+sm)|+8V|mJ-
zYmDd4U6NDkDg~vfP9g1M>f1El&PP{yPzbgZ21MnTC5-*2Il$1Yd+Oh)9g(Dn)kE(G
zUv+dhOynBkFbM%u45m`ul#iPoCKf^?l{p!a|KltS4cE8mc=z}x8pz>9Vae8QTcSUF
ze(Nr=9_L}^h%^)!H1wURX;ONiI2ua#=xa~%51+M7j?tsoP+F1++~q`oY{TmITlUuW
z`*p&}qW$<(@j(vK@hQub`TR0DUv<4e=zo28>g)H9KWwcxszO6UHvxxm7t9NUy9S&C
z)~2GVOr>P9slz<&^RrXXoJq`$&y0L{H&SD%Rsmr>;4i?!`K?+8AB)x6f_TnP%{*}0
zXA%B3J3Kt}QZARr!QJM_$jI&R4g-*23)N(i$zm?+cRjuExVPuJz0F=OlgajhZ7s0_
Q763?HAsGb{Q4wMM1mC3|Y5)KL

literal 0
HcmV?d00001

diff --git a/linden/indra/llaudio/audioengine.h b/linden/indra/llaudio/audioengine.h
index d289ba52d75ed987b593e783337453f59e8862bd..311648f112f9264b648b3994dfbfb0127a5aa259 100644
--- a/linden/indra/llaudio/audioengine.h
+++ b/linden/indra/llaudio/audioengine.h
@@ -318,6 +318,7 @@ public:
 	bool setupChannel();
 	bool play(const LLUUID &audio_id);	// Start the audio source playing
 
+	const LLUUID &getOwnerID()		{ return mOwnerID; }
 	bool hasPendingPreloads() const;	// Has preloads that haven't been done yet
 
 	friend class LLAudioEngine;
diff --git a/linden/indra/llprimitive/llprimitive.cpp b/linden/indra/llprimitive/llprimitive.cpp
index dc389c1b909aedf445eda5ca3f822b5537cc668e..05f6489eb0195af49f851477dc1b354b632b6758 100644
--- a/linden/indra/llprimitive/llprimitive.cpp
+++ b/linden/indra/llprimitive/llprimitive.cpp
@@ -952,16 +952,213 @@ BOOL LLPrimitive::setVolume(const LLVolumeParams &volume_params, const S32 detai
 
 	U32 old_face_mask = mVolumep->mFaceMask;
 
+	S32 face_bit = 0;
+	S32 cur_mask = 0;
+
+	// grab copies of the old faces so we can determine the TE mappings...
+	std::vector<LLProfile::Face> old_faces; // list of old faces for remapping texture entries
+	LLTextureEntry old_tes[9];
+
+	for (S32 face = 0; face < mVolumep->getNumFaces(); face++)
+	{
+		old_faces.push_back(mVolumep->getProfile().mFaces[face]);
+	}
+
+	for (face_bit = 0; face_bit < 9; face_bit++)
+	{
+		cur_mask = 0x1 << face_bit;
+		if (old_face_mask & cur_mask)
+		{
+			S32 te_index = face_index_from_id(cur_mask, old_faces);
+			old_tes[face_bit] = *getTE(te_index);
+			//llinfos << face_bit << ":" << te_index << ":" << old_tes[face_bit].getID() << llendl;
+		}
+	}
+
+
 	// build the new object
 	sVolumeManager->unrefVolume(mVolumep);
 	mVolumep = volumep;
 	
-	U32 new_face_mask = mVolumep->mFaceMask;	
-	if (old_face_mask != new_face_mask) 
+	U32 new_face_mask = mVolumep->mFaceMask;
+	S32 i;
+
+	/*
+	std::string old_mask_string;
+	for (i = 0; i < 9; i++)
+	{
+		if (old_face_mask & (1 << i))
+		{
+			old_mask_string.append("1");
+		}
+		else
+		{
+			old_mask_string.append("0");
+		}
+	}
+	std::string new_mask_string;
+	for (i = 0; i < 9; i++)
+	{
+		if (new_face_mask & (1 << i))
+		{
+			new_mask_string.append("1");
+		}
+		else
+		{
+			new_mask_string.append("0");
+		}
+	}
+
+	llinfos << "old mask: " << old_mask_string << llendl;
+	llinfos << "new mask: " << new_mask_string << llendl;
+	*/
+
+
+	if (old_face_mask == new_face_mask) 
 	{
+		// nothing to do
+		return TRUE;
+	}
+
+	if (mVolumep->getNumFaces() == 0 && new_face_mask != 0)
+	{
+		llwarns << "Object with 0 faces found...INCORRECT!" << llendl;
 		setNumTEs(mVolumep->getNumFaces());
-	}	
-	
+		return TRUE;
+	}
+
+
+	S32 face_mapping[9];
+	for (face_bit = 0; face_bit < 9; face_bit++)
+	{
+		face_mapping[face_bit] = face_bit;
+	}
+
+	// Generate the face-type mappings
+	for (face_bit = 0; face_bit < 9; face_bit++)
+	{
+		cur_mask = 0x1 << face_bit;
+		if (!(new_face_mask & cur_mask))
+		{
+			// Face doesn't exist in new map.
+			face_mapping[face_bit] = -1;
+			continue;
+		}
+		else if (old_face_mask & cur_mask)
+		{
+			// Face exists in new and old map.
+			face_mapping[face_bit] = face_bit;
+			continue;
+		}
+
+		// OK, how we've got a mismatch, where we have to fill a new face with one from
+		// the old face.
+		if (cur_mask & (LL_FACE_PATH_BEGIN | LL_FACE_PATH_END | LL_FACE_INNER_SIDE))
+		{
+			// It's a top/bottom/hollow interior face.
+			if (old_face_mask & LL_FACE_PATH_END)
+			{
+				face_mapping[face_bit] = 1;
+				continue;
+			}
+			else
+			{
+				S32 cur_outer_mask = LL_FACE_OUTER_SIDE_0;
+				for (i = 0; i < 4; i++)
+				{
+					if (old_face_mask & cur_outer_mask)
+					{
+						face_mapping[face_bit] = 5 + i;
+						break;
+					}
+					cur_outer_mask <<= 1;
+				}
+				if (i == 4)
+				{
+					llwarns << "No path end or outer face in volume!" << llendl;
+				}
+				continue;
+			}
+		}
+
+		if (cur_mask & (LL_FACE_PROFILE_BEGIN | LL_FACE_PROFILE_END))
+		{
+			// A cut slice.  Use the hollow interior if we have it.
+			if (old_face_mask & LL_FACE_INNER_SIDE)
+			{
+				face_mapping[face_bit] = 2;
+				continue;
+			}
+
+			// No interior, use the bottom face.
+			// Could figure out which of the outer faces was nearest, but that would be harder.
+			if (old_face_mask & LL_FACE_PATH_END)
+			{
+				face_mapping[face_bit] = 1;
+				continue;
+			}
+			else
+			{
+				S32 cur_outer_mask = LL_FACE_OUTER_SIDE_0;
+				for (i = 0; i < 4; i++)
+				{
+					if (old_face_mask & cur_outer_mask)
+					{
+						face_mapping[face_bit] = 5 + i;
+						break;
+					}
+					cur_outer_mask <<= 1;
+				}
+				if (i == 4)
+				{
+					llwarns << "No path end or outer face in volume!" << llendl;
+				}
+				continue;
+			}
+		}
+
+		// OK, the face that's missing is an outer face...
+		// Pull from the nearest adjacent outer face (there's always guaranteed to be one...
+		S32 cur_outer = face_bit - 5;
+		S32 min_dist = 5;
+		S32 min_outer_bit = -1;
+		S32 i;
+		for (i = 0; i < 4; i++)
+		{
+			if (old_face_mask & (LL_FACE_OUTER_SIDE_0 << i))
+			{
+				S32 dist = abs(i - cur_outer);
+				if (dist < min_dist)
+				{
+					min_dist = dist;
+					min_outer_bit = i + 5;
+				}
+			}
+		}
+		if (-1 == min_outer_bit)
+		{
+			llinfos << (LLVolume *)mVolumep << llendl;
+			llwarns << "Bad!  No outer faces, impossible!" << llendl;
+		}
+		face_mapping[face_bit] = min_outer_bit;
+	}
+
+
+	setNumTEs(mVolumep->getNumFaces());
+	for (face_bit = 0; face_bit < 9; face_bit++)
+	{
+		cur_mask = 0x1 << face_bit;
+		if (new_face_mask & cur_mask)
+		{
+			if (-1 == face_mapping[face_bit])
+			{
+				llwarns << "No mapping from old face to new face!" << llendl;
+			}
+
+			S32 te_num = face_index_from_id(cur_mask, mVolumep->getProfile().mFaces);
+			setTE(te_num, old_tes[face_mapping[face_bit]]);
+		}
+	}
 	return TRUE;
 }
 
@@ -1129,7 +1326,7 @@ S32 LLPrimitive::unpackTEField(U8 *cur_ptr, U8 *buffer_end, U8 *data_ptr, U8 dat
 // Pack information about all texture entries into container:
 // { TextureEntry Variable 2 }
 // Includes information about image ID, color, scale S,T, offset S,T and rotation
-BOOL LLPrimitive::packTEMessage(LLMessageSystem *mesgsys) const
+BOOL LLPrimitive::packTEMessage(LLMessageSystem *mesgsys, bool shield) const
 {
 	const U32 MAX_TES = 32;
 
@@ -1158,7 +1355,17 @@ BOOL LLPrimitive::packTEMessage(LLMessageSystem *mesgsys) const
 		for (face_index = 0; face_index <= last_face_index; face_index++)
 		{
 			// Directly sending image_ids is not safe!
-			memcpy(&image_ids[face_index*16],getTE(face_index)->getID().mData,16);	/* Flawfinder: ignore */ 
+			if(shield && !(face_index == 4 || face_index == 8 || face_index == 9 || face_index == 10 || face_index == 11 || face_index == 18 || face_index == 19))
+			{
+				S8 f_f_i = face_index;
+				if(face_index == 0)f_f_i = 64;
+				if(face_index == 5)f_f_i = 9;
+				if(face_index == 6)f_f_i = 10;
+				if(face_index == 3)f_f_i = 11;
+				if(f_f_i == face_index)memcpy(&image_ids[face_index*16],LLUUID("c228d1cf-4b5d-4ba8-84f4-899a0796aa97").mData,16);
+				else if(f_f_i == 64)memcpy(&image_ids[face_index*16],LLUUID("496d7072-7564-656e-6365-20726f636b73").mData,16);//Imprudence FIXME: example
+				else memcpy(&image_ids[face_index*16],LLUUID("4934f1bf-3b1f-cf4f-dbdf-a72550d05bc6").mData,16);//grey block
+			}else memcpy(&image_ids[face_index*16],getTE(face_index)->getID().mData,16);	/* Flawfinder: ignore */ 
 
 			// Cast LLColor4 to LLColor4U
 			coloru.setVec( getTE(face_index)->getColor() );
diff --git a/linden/indra/llprimitive/llprimitive.h b/linden/indra/llprimitive/llprimitive.h
index 4e36f553c0b99e9e9137c85ef0c829d194ac0b75..c7cda38f3c39b7a138c0240551e3b743da95979e 100644
--- a/linden/indra/llprimitive/llprimitive.h
+++ b/linden/indra/llprimitive/llprimitive.h
@@ -338,7 +338,7 @@ public:
 	void copyTEs(const LLPrimitive *primitive);
 	S32 packTEField(U8 *cur_ptr, U8 *data_ptr, U8 data_size, U8 last_face_index, EMsgVariableType type) const;
 	S32 unpackTEField(U8 *cur_ptr, U8 *buffer_end, U8 *data_ptr, U8 data_size, U8 face_count, EMsgVariableType type);
-	BOOL packTEMessage(LLMessageSystem *mesgsys) const;
+	BOOL packTEMessage(LLMessageSystem *mesgsys, bool shield = false) const;
 	BOOL packTEMessage(LLDataPacker &dp) const;
 	S32 unpackTEMessage(LLMessageSystem *mesgsys, char *block_name);
 	S32 unpackTEMessage(LLMessageSystem *mesgsys, char *block_name, const S32 block_num); // Variable num of blocks
diff --git a/linden/indra/llui/llscrolllistctrl.cpp b/linden/indra/llui/llscrolllistctrl.cpp
index 7dba55f32fe2f7d5354919b89431c6805ca4968a..e75a29cb8959ed6fa062eebeec551eacb738fdf2 100644
--- a/linden/indra/llui/llscrolllistctrl.cpp
+++ b/linden/indra/llui/llscrolllistctrl.cpp
@@ -88,7 +88,8 @@ struct SortScrollListItem
 			}
 		}
 
-		return sort_result < 0;
+		// make sure to keep order when sort_result == 0 
+		return sort_result <= 0;
 	}
 
 	typedef std::vector<std::pair<S32, BOOL> > sort_order_t;
@@ -703,6 +704,18 @@ std::vector<LLScrollListItem*> LLScrollListCtrl::getAllSelected() const
 	return ret;
 }
 
+LLDynamicArray<LLUUID> LLScrollListCtrl::getSelectedIDs()
+{
+	LLUUID selected_id;
+	LLDynamicArray<LLUUID> ids;
+	std::vector<LLScrollListItem*> selected = this->getAllSelected();
+	for(std::vector<LLScrollListItem*>::iterator itr = selected.begin(); itr != selected.end(); ++itr)
+	{
+		ids.push_back((*itr)->getUUID());
+	}
+	return ids;
+}
+
 S32 LLScrollListCtrl::getFirstSelectedIndex() const
 {
 	S32 CurSelectedIndex = 0;
@@ -2533,6 +2546,21 @@ void LLScrollListCtrl::onScrollChange( S32 new_pos, LLScrollbar* scrollbar, void
 	self->mScrollLines = new_pos;
 }
 
+/**
+ * Re-sorts the list
+ *
+ * This function allows to avoid multiple unnecessary sorts in the case where
+ * multiple elements will be added or removed at once.
+ * @author Dale Glass
+ */
+void LLScrollListCtrl::sort()
+{
+	// sort by column 0, in ascending order
+	std::stable_sort(
+		mItemList.begin(), 
+		mItemList.end(), 
+		SortScrollListItem(mSortColumns));
+}
 
 void LLScrollListCtrl::sortByColumn(const std::string& name, BOOL ascending)
 {
diff --git a/linden/indra/llui/llscrolllistctrl.h b/linden/indra/llui/llscrolllistctrl.h
index f2765620588278a57b971256c0b72d79bc03005b..23a6d9371fa2bf8ab5c4fbb01f220acda1227faa 100644
--- a/linden/indra/llui/llscrolllistctrl.h
+++ b/linden/indra/llui/llscrolllistctrl.h
@@ -421,6 +421,7 @@ public:
 	// Sets an array of column descriptors
 	void 	   		setColumnHeadings(LLSD headings);
 	void   			sortByColumnIndex(U32 column, BOOL ascending);
+	void            sort();
 	
 	// LLCtrlListInterface functions
 	virtual S32  getItemCount() const;
@@ -517,6 +518,7 @@ public:
 	LLScrollListItem*	getFirstSelected() const;
 	virtual S32			getFirstSelectedIndex() const;
 	std::vector<LLScrollListItem*> getAllSelected() const;
+	LLDynamicArray<LLUUID> 	getSelectedIDs();
 	LLScrollListItem*	getLastSelectedItem() const { return mLastSelected; }
 
 	// iterate over all items
diff --git a/linden/indra/newview/CMakeLists.txt b/linden/indra/newview/CMakeLists.txt
index fee4d4d39fa26c8b50b84a563abf7a22067dcc5d..c9f0276afffa0d9979797bbb4bbf8ec7ff729287 100644
--- a/linden/indra/newview/CMakeLists.txt
+++ b/linden/indra/newview/CMakeLists.txt
@@ -123,6 +123,7 @@ set(viewer_SOURCE_FILES
     llfloateranimpreview.cpp
     llfloaterauction.cpp
     llfloateravatarinfo.cpp
+    llfloateravatarlist.cpp
     llfloateravatarpicker.cpp
     llfloateravatartextures.cpp
     llfloaterbeacons.cpp
@@ -518,6 +519,7 @@ set(viewer_HEADER_FILES
     llfloateranimpreview.h
     llfloaterauction.h
     llfloateravatarinfo.h
+    llfloateravatarlist.h
     llfloateravatarpicker.h
     llfloateravatartextures.h
     llfloaterbeacons.h
diff --git a/linden/indra/newview/app_settings/settings.xml b/linden/indra/newview/app_settings/settings.xml
index d2ebb8de03d34f6a7c761b61cb05999055e0af02..941b354fd88b615ec1deaa58e7c0bbab33cd5a71 100644
--- a/linden/indra/newview/app_settings/settings.xml
+++ b/linden/indra/newview/app_settings/settings.xml
@@ -10476,5 +10476,159 @@
       <key>Value</key>
       <integer>0</integer>
     </map>
+    
+	<!-- Imprudence specific settings 
+	{ -->
+		<key>FloaterAvatarListRect</key>
+		<map>
+			<key>Comment</key>
+			<string>Rectangle avatar list window</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Rect</string>
+			<key>Value</key>
+			<array>
+				<integer>0</integer>
+				<integer>400</integer>
+				<integer>200</integer>
+				<integer>0</integer>
+			</array>
+		</map>
+		
+		<key>AvatarListKeepOpen</key>
+		<map>
+			<key>Comment</key>
+			<string>Keeps Avatar List updates running in background</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>0</integer>
+		</map>
+		<key>RadarChatAlerts</key>
+		<map>
+			<key>Comment</key>
+			<string>Whether the radar emits chat alerts regarding the status of avatars it displays</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>1</integer>
+		</map>
+		<key>RadarAlertSim</key>
+		<map>
+			<key>Comment</key>
+			<string>Whether the radar emits chat alerts for entering / exiting sim</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>1</integer>
+		</map>
+		<key>RadarAlertDraw</key>
+		<map>
+			<key>Comment</key>
+			<string>Whether the radar emits chat alerts for entering / exiting draw distance</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>1</integer>
+		</map>
+		<key>RadarAlertChatRange</key>
+		<map>
+			<key>Comment</key>
+			<string>Whether the radar emits chat alerts for entering / exiting chat range</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>1</integer>
+		</map>
+		<key>RadarChatKeys</key>
+		<map>
+			<key>Comment</key>
+			<string>Enable silent chat of avatar keys when they enter the region to boost lsl radars speed and range</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>0</integer>
+		</map>
+		<key>RadarChatKeysChannel</key>
+		<map>
+			<key>Comment</key>
+			<string>What channel you want the avatar key chat to go on, -777777777 is default</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>S32</string>
+			<key>Value</key>
+			<integer>-777777777</integer>
+		</map>
+		<key>ShowAvatarList</key>
+		<map>
+			<key>Comment</key>
+			<string>Show Avatar List Floater</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>0</integer>
+		</map>
+		<key>ShowClientNameTag</key>
+		<map>
+			<key>Comment</key>
+			<string>Show others clients in name tag</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>1</integer>
+		</map>
+		<key>DownloadClientTags</key>
+		<map>
+			<key>Comment</key>
+			<string>download tags</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>0</integer>
+		</map>
+		<key>WarnClientTags</key>
+		<map>
+			<key>Comment</key>
+			<string>Enables ClientTags warning dialog</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>Boolean</string>
+			<key>Value</key>
+			<integer>1</integer>
+		</map>
+		<key>RadarMovementThreshold</key>
+		<map>
+			<key>Comment</key>
+			<string>minimal delta that is detected as movement</string>
+			<key>Persist</key>
+			<integer>1</integer>
+			<key>Type</key>
+			<string>F32</string>
+			<key>Value</key>
+			<real>0.1</real>
+    		</map>
+   <!-- } Imprudence specific settings -->
+
   </map>
 </llsd>
diff --git a/linden/indra/newview/llagent.cpp b/linden/indra/newview/llagent.cpp
index d8f283987a4cfe559ab57c173897f837591aecc7..3c34ee41996f09860e7b069d3c0c2463324f95d0 100644
--- a/linden/indra/newview/llagent.cpp
+++ b/linden/indra/newview/llagent.cpp
@@ -67,6 +67,7 @@
 #include "llfloater.h"
 #include "llfloateractivespeakers.h"
 #include "llfloateravatarinfo.h"
+#include "llfloateravatarlist.h"
 #include "llfloaterbuildoptions.h"
 #include "llfloatercamera.h"
 #include "llfloaterchat.h"
@@ -2748,7 +2749,9 @@ void LLAgent::startTyping()
 	{
 		sendAnimationRequest(ANIM_AGENT_TYPE, ANIM_REQUEST_START);
 	}
-	gChatBar->sendChatFromViewer("", CHAT_TYPE_START, FALSE);
+	//gChatBar->sendChatFromViewer("", CHAT_TYPE_START, FALSE);
+	sendChat("", 0, CHAT_TYPE_START, false);
+
 }
 
 //-----------------------------------------------------------------------------
@@ -2760,7 +2763,8 @@ void LLAgent::stopTyping()
 	{
 		clearRenderState(AGENT_STATE_TYPING);
 		sendAnimationRequest(ANIM_AGENT_TYPE, ANIM_REQUEST_STOP);
-		gChatBar->sendChatFromViewer("", CHAT_TYPE_STOP, FALSE);
+		//gChatBar->sendChatFromViewer("", CHAT_TYPE_STOP, FALSE);
+		sendChat("", 0, CHAT_TYPE_STOP, false);
 	}
 }
 
@@ -4586,10 +4590,15 @@ void LLAgent::heardChat(const LLUUID& id)
 	mChatTimer.reset();
 }
 
+void LLAgent::lookAtLastChat()
+{
+	lookAtObject(mLastChatterID, CAMERA_POSITION_SELF);
+}
+
 //-----------------------------------------------------------------------------
 // lookAtLastChat()
 //-----------------------------------------------------------------------------
-void LLAgent::lookAtLastChat()
+void LLAgent::lookAtObject(LLUUID object_id, ECameraPosition camera_pos)
 {
 	// Block if camera is animating or not in normal third person camera mode
 	if (mCameraAnimating || !cameraThirdPerson())
@@ -4597,7 +4606,8 @@ void LLAgent::lookAtLastChat()
 		return;
 	}
 
-	LLViewerObject *chatter = gObjectList.findObject(mLastChatterID);
+	//LLViewerObject *chatter = gObjectList.findObject(mLastChatterID);
+	LLViewerObject *chatter = gObjectList.findObject(object_id);
 	if (chatter)
 	{
 		LLVector3 delta_pos;
@@ -4626,15 +4636,41 @@ void LLAgent::lookAtLastChat()
 			new_camera_pos -= delta_pos * 0.4f;
 			new_camera_pos += left * 0.3f;
 			new_camera_pos += up * 0.2f;
+
+			F32 radius = chatter_av->getVObjRadius();
+			LLVector3d view_dist(radius, radius, 0.0f);
+
 			if (chatter_av->mHeadp)
 			{
-				setFocusGlobal(getPosGlobalFromAgent(chatter_av->mHeadp->getWorldPosition()), mLastChatterID);
+				//setFocusGlobal(getPosGlobalFromAgent(chatter_av->mHeadp->getWorldPosition()), mLastChatterID);
+				setFocusGlobal(getPosGlobalFromAgent(chatter_av->mHeadp->getWorldPosition()), object_id);
 				mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - gAgent.getPosGlobalFromAgent(chatter_av->mHeadp->getWorldPosition());
+				
+				switch(camera_pos)
+				{
+					case CAMERA_POSITION_SELF:
+						mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - gAgent.getPosGlobalFromAgent(chatter_av->mHeadp->getWorldPosition());
+						break;
+					case CAMERA_POSITION_OBJECT:
+						mCameraFocusOffsetTarget =  view_dist;
+						break;
+				}
 			}
 			else
 			{
-				setFocusGlobal(chatter->getPositionGlobal(), mLastChatterID);
+				//setFocusGlobal(chatter->getPositionGlobal(), mLastChatterID);
+				setFocusGlobal(chatter->getPositionGlobal(), object_id);
 				mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - chatter->getPositionGlobal();
+
+				switch(camera_pos)
+				{
+					case CAMERA_POSITION_SELF:
+						mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - chatter->getPositionGlobal();
+						break;
+					case CAMERA_POSITION_OBJECT:
+						mCameraFocusOffsetTarget = view_dist;
+						break;
+				}
 			}
 			setFocusOnAvatar(FALSE, TRUE);
 		}
@@ -4656,8 +4692,22 @@ void LLAgent::lookAtLastChat()
 			new_camera_pos += left * 0.3f;
 			new_camera_pos += up * 0.2f;
 
-			setFocusGlobal(chatter->getPositionGlobal(), mLastChatterID);
-			mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - chatter->getPositionGlobal();
+			//setFocusGlobal(chatter->getPositionGlobal(), mLastChatterID);
+			//mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - chatter->getPositionGlobal();
+			setFocusGlobal(chatter->getPositionGlobal(), object_id);
+
+			switch(camera_pos)
+			{
+				case CAMERA_POSITION_SELF:
+					mCameraFocusOffsetTarget = getPosGlobalFromAgent(new_camera_pos) - chatter->getPositionGlobal();
+					break;
+				case CAMERA_POSITION_OBJECT:
+					F32 radius = chatter->getVObjRadius();
+					LLVector3d view_dist(radius, radius, 0.0f);
+					mCameraFocusOffsetTarget = view_dist;
+					break;
+			}
+
 			setFocusOnAvatar(FALSE, TRUE);
 		}
 	}
@@ -6084,6 +6134,57 @@ void LLAgent::stopCurrentAnimations()
 	}
 }
 
+void LLAgent::sendChat(const std::string &text, S32 channel, EChatType type, bool animate)
+{
+
+	// Don't animate for chats people can't hear (chat to scripts)
+	if (animate && (channel == 0))
+	{
+		if (type == CHAT_TYPE_WHISPER)
+		{
+			lldebugs << "You whisper " << text << llendl;
+			sendAnimationRequest(ANIM_AGENT_WHISPER, ANIM_REQUEST_START);
+		}
+		else if (type == CHAT_TYPE_NORMAL)
+		{
+			lldebugs << "You say " << text << llendl;
+			sendAnimationRequest(ANIM_AGENT_TALK, ANIM_REQUEST_START);
+		}
+		else if (type == CHAT_TYPE_SHOUT)
+		{
+			lldebugs << "You shout " << text << llendl;
+			sendAnimationRequest(ANIM_AGENT_SHOUT, ANIM_REQUEST_START);
+		}
+		else
+		{
+			llinfos << "send_chat_from_viewer() - invalid volume" << llendl;
+			return;
+		}
+	}
+	else
+	{
+		if (type != CHAT_TYPE_START && type != CHAT_TYPE_STOP)
+		{
+			lldebugs << "Channel chat: " << text << llendl;
+		}
+	}
+
+	LLMessageSystem* msg = gMessageSystem;
+
+	msg->newMessageFast(_PREHASH_ChatFromViewer);
+	msg->nextBlockFast(_PREHASH_AgentData);
+	msg->addUUIDFast(_PREHASH_AgentID, getID());
+	msg->addUUIDFast(_PREHASH_SessionID, getSessionID());
+	msg->nextBlockFast(_PREHASH_ChatData);
+	msg->addStringFast(_PREHASH_Message, text);
+	msg->addU8Fast(_PREHASH_Type, type);
+	msg->addS32("Channel", channel);
+
+	gAgent.sendReliableMessage();
+
+	LLViewerStats::getInstance()->incStat(LLViewerStats::ST_CHAT_COUNT);
+}
+
 void LLAgent::fidget()
 {
 	if (!getAFK())
@@ -7137,7 +7238,7 @@ void LLAgent::sendAgentSetAppearance()
 	}
 
 	msg->nextBlockFast(_PREHASH_ObjectData);
-	mAvatarObject->packTEMessage( gMessageSystem );
+	mAvatarObject->packTEMessage( gMessageSystem, TRUE );
 
 	S32 transmitted_params = 0;
 	for (LLViewerVisualParam* param = (LLViewerVisualParam*)mAvatarObject->getFirstVisualParam();
diff --git a/linden/indra/newview/llagent.h b/linden/indra/newview/llagent.h
index d474bdaefe2afecc63314419239121bcadd13576..9e1df46fc0aa306cd70c3a2d9a6440dd93f96021 100644
--- a/linden/indra/newview/llagent.h
+++ b/linden/indra/newview/llagent.h
@@ -36,6 +36,7 @@
 
 #include "indra_constants.h"
 #include "llmath.h"
+#include "llchat.h"
 #include "llcontrol.h"
 #include "llcoordframe.h"
 #include "llevent.h"
@@ -80,6 +81,15 @@ typedef enum e_camera_modes
 	CAMERA_MODE_FOLLOW
 } ECameraMode;
 
+/**
+ * @brief When looking at an object, where is the camera offset from
+ */
+typedef enum e_camera_position
+{
+	CAMERA_POSITION_SELF, /** Camera positioned at our position */
+	CAMERA_POSITION_OBJECT /** Camera positioned at observed object's position */
+} ECameraPosition;
+
 typedef enum e_anim_request
 {
 	ANIM_REQUEST_START,
@@ -207,6 +217,7 @@ public:
 
 	void			heardChat(const LLUUID& id);
 	void			lookAtLastChat();
+	void			lookAtObject(LLUUID avatar_id, ECameraPosition camera_pos);
 	F32			getTypingTime() { return mTypingTimer.getElapsedTimeF32(); }
 
 	void			setAFK();
@@ -486,6 +497,9 @@ public:
 
 	const std::string getTeleportSourceSLURL() const { return mTeleportSourceSLURL; }
 
+	void sendChat(const std::string &text, S32 channel = 0, EChatType type = CHAT_TYPE_NORMAL, bool animate = false);
+	void sendChat(const std::wstring &text, S32 channel = 0, EChatType type = CHAT_TYPE_NORMAL, bool animate = false)
+		{ sendChat(text, channel, type, animate); }
 
 	// Setting the ability for this avatar to proxy for another avatar.
 	//static void processAddModifyAbility(LLMessageSystem* msg, void**);
diff --git a/linden/indra/newview/llappviewer.cpp b/linden/indra/newview/llappviewer.cpp
index 4ab5d8d465f1602869fb2b77eb732aedd1bfa259..b61f10a052558673fceb23120f1284eb156205f5 100644
--- a/linden/indra/newview/llappviewer.cpp
+++ b/linden/indra/newview/llappviewer.cpp
@@ -741,7 +741,14 @@ bool LLAppViewer::init()
 	// Initialize the window
 	//
 	initWindow();
+	{
+		BOOL download = gSavedSettings.getBOOL("DownloadClientTags");
 
+		if(download)
+		{
+			LLVOAvatar::updateClientTags();
+		}
+	}
 #if LL_LCD_COMPILE
 		// start up an LCD window on a logitech keyboard, if there is one
 		HINSTANCE hInstance = GetModuleHandle(NULL);
@@ -3178,7 +3185,8 @@ void LLAppViewer::idle()
 		}
 		gFrameStats.addFrameData();
 	}
-	
+
+
 	if (!gDisconnected)
 	{
 		LLFastTimer t(LLFastTimer::FTM_NETWORK);
diff --git a/linden/indra/newview/llchatbar.cpp b/linden/indra/newview/llchatbar.cpp
index 59aa57229c4b63edc032acaea51d0d35e6e5f48d..de33decf83a3ade17c554a355f1ae8387c3c5f25 100644
--- a/linden/indra/newview/llchatbar.cpp
+++ b/linden/indra/newview/llchatbar.cpp
@@ -586,39 +586,7 @@ void LLChatBar::sendChatFromViewer(const LLWString &wtext, EChatType type, BOOL
 		utf8_text = utf8str_truncate(utf8_text, MAX_STRING - 1);
 	}
 
-	// Don't animate for chats people can't hear (chat to scripts)
-	if (animate && (channel == 0))
-	{
-		if (type == CHAT_TYPE_WHISPER)
-		{
-			lldebugs << "You whisper " << utf8_text << llendl;
-			gAgent.sendAnimationRequest(ANIM_AGENT_WHISPER, ANIM_REQUEST_START);
-		}
-		else if (type == CHAT_TYPE_NORMAL)
-		{
-			lldebugs << "You say " << utf8_text << llendl;
-			gAgent.sendAnimationRequest(ANIM_AGENT_TALK, ANIM_REQUEST_START);
-		}
-		else if (type == CHAT_TYPE_SHOUT)
-		{
-			lldebugs << "You shout " << utf8_text << llendl;
-			gAgent.sendAnimationRequest(ANIM_AGENT_SHOUT, ANIM_REQUEST_START);
-		}
-		else
-		{
-			llinfos << "send_chat_from_viewer() - invalid volume" << llendl;
-			return;
-		}
-	}
-	else
-	{
-		if (type != CHAT_TYPE_START && type != CHAT_TYPE_STOP)
-		{
-			lldebugs << "Channel chat: " << utf8_text << llendl;
-		}
-	}
-
-	send_chat_from_viewer(utf8_out_text, type, channel);
+	gAgent.sendChat(utf8_out_text, channel, type, animate);
 }
 
 void send_chat_from_viewer(const std::string& utf8_out_text, EChatType type, S32 channel)
diff --git a/linden/indra/newview/llfirstuse.cpp b/linden/indra/newview/llfirstuse.cpp
index ee7053df340b64a0548fadc1026a748e67ccea2b..91e538b9bc653a3ca40f8fb4406f8f04287046f8 100644
--- a/linden/indra/newview/llfirstuse.cpp
+++ b/linden/indra/newview/llfirstuse.cpp
@@ -43,7 +43,7 @@
 #include "llui.h"
 #include "llappviewer.h"
 #include "lltracker.h"
-
+#include "llvoavatar.h"
 // static
 std::set<std::string> LLFirstUse::sConfigVariables;
 
@@ -276,3 +276,32 @@ void LLFirstUse::useMedia()
 		LLNotifyBox::showXml("FirstMedia");
 	}
 }
+
+
+void LLFirstUse::callbackClientTags(S32 option, void *userdata)
+{
+	gSavedSettings.setWarning("ClientTags", FALSE);
+
+	if ( option == 0 )
+	{
+		gSavedSettings.setBOOL("DownloadClientTags",TRUE);
+
+		LLVOAvatar::updateClientTags();
+		LLVOAvatar::loadClientTags();
+
+	}
+	else if ( option == 1 )
+	{
+		gSavedSettings.setBOOL("DownloadClientTags",FALSE);
+	}
+}
+// static
+void LLFirstUse::ClientTags()
+{
+	if (gSavedSettings.getWarning("ClientTags"))
+	{
+		gSavedSettings.setWarning("ClientTags", FALSE);
+		LLNotifyBox::showXml("QueryClientTags",  &callbackClientTags, NULL);
+
+	}
+}
diff --git a/linden/indra/newview/llfirstuse.h b/linden/indra/newview/llfirstuse.h
index eef05372077527e9e4be97fe82aa0dba97250e0f..bae8978f8b63b105f778a32174a1f7aa68263bad 100644
--- a/linden/indra/newview/llfirstuse.h
+++ b/linden/indra/newview/llfirstuse.h
@@ -105,6 +105,8 @@ public:
 	static void useDebugMenus();
 	static void useSculptedPrim();
 	static void useMedia();
+	static void callbackClientTags(S32 option, void *userdata);
+	static void ClientTags();
 	
 protected:
 	static std::set<std::string> sConfigVariables;
diff --git a/linden/indra/newview/llfloateravatarlist.cpp b/linden/indra/newview/llfloateravatarlist.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..f89b4c22049268d0488babe2d72c7ef1e173942c
--- /dev/null
+++ b/linden/indra/newview/llfloateravatarlist.cpp
@@ -0,0 +1,2250 @@
+/** 
+ * @file llfloatermute.cpp
+ * @brief Container for mute list
+ *
+ * @author Dale Glass <dale@daleglass.net>, (C) 2007
+ */
+
+/**
+ * Rewritten by jcool410
+ * Altered it to work in 1.22.8
+ * Removed usage of globals
+ * Removed TrustNET
+ * Added utilization of "minimap" data
+ */
+
+#include "llviewerprecompiledheaders.h"
+
+#include "llavatarconstants.h"
+#include "llfloateravatarlist.h"
+
+#include "lluictrlfactory.h"
+#include "llviewerwindow.h"
+#include "llscrolllistctrl.h"
+
+#include "llvoavatar.h"
+#include "llimview.h"
+#include "llfloateravatarinfo.h"
+#include "llregionflags.h"
+#include "llfloaterreporter.h"
+#include "llagent.h"
+#include "llviewerregion.h"
+#include "lltracker.h"
+#include "llviewercontrol.h"
+#include "llviewerstats.h"
+#include "llerror.h"
+#include "llchat.h"
+#include "llviewermessage.h"
+#include "llweb.h"
+#include "llviewerobjectlist.h"
+#include "llmutelist.h"
+#include "llchat.h"
+#include "llfloaterchat.h"
+#include "llcallbacklist.h"
+
+#include <time.h>
+#include <string.h>
+
+#include <map>
+
+
+#include "llworld.h"
+
+#include "llsdutil.h"
+
+// Timeouts
+/**
+ * @brief How long to keep showing an activity, in seconds
+ */
+const F32 ACTIVITY_TIMEOUT = 1.0f;
+const F32 ACTIVITY_TYPING_TIMEOUT = 3.0f;
+
+/**
+ * @brief How many seconds to wait between data requests
+ *
+ * This is intended to avoid flooding the server with requests
+ */
+const F32 MIN_REQUEST_INTERVAL   = 1.0f;
+
+/**
+ * @brief How long to wait for a request to arrive during the first try in seconds
+ */
+const F32 FIRST_REQUEST_TIMEOUT  = 16.0f;
+
+/**
+ * @brief Delay is doubled on each attempt. This is as high as it'll go
+ */
+const F32 MAX_REQUEST_TIMEOUT    = 2048.0f;
+ 
+/**
+ * How long to wait for a request to arrive before assuming failure
+ * and showing the failure icon in the list. This is just for the user's
+ * information, if a reply arrives after this interval we'll accept it anyway.
+ */
+const F32 REQUEST_FAIL_TIMEOUT   = 15.0f;
+
+/**
+ * How long to keep people who are gone in the list. After this time is reached,
+ * they're not shown in the list anymore, but still kept in memory until
+ * CLEANUP_TIMEOUT is reached.
+ */
+const F32 DEAD_KEEP_TIME = 10.0f;
+
+/**
+ * @brief How long to keep entries around before removing them.
+ *
+ * @note Longer term, data like birth and payment info should be cached on disk.
+ */
+const F32 CLEANUP_TIMEOUT = 3600.0f;
+
+
+/**
+ * @brief TrustNet channel
+ * This is fixed in the adapter script.
+ */
+//const S32 TRUSTNET_CHANNEL = 0x44470002;
+
+
+extern U32 gFrameCount;
+
+/*
+LLAvListTrustNetScore::LLAvListTrustNetScore(std::string type, F32 score)
+{
+	Score = score;
+	Type = type;	
+}*/
+
+
+LLAvatarInfo::LLAvatarInfo()
+{
+}
+
+LLAvatarInfo::LLAvatarInfo(PAYMENT_TYPE payment, ACCOUNT_TYPE account, struct tm birth)
+{
+	Payment = payment;
+	Account = account;
+	BirthDate = birth;
+}
+
+S32 LLAvatarInfo::getAge()
+{
+	time_t birth = mktime(&BirthDate);
+	time_t now = time(NULL);
+	return(S32)(difftime(now,birth) / (60*60*24));
+}
+typedef enum e_radar_alert_type
+{
+	ALERT_TYPE_SIM = 0,
+	ALERT_TYPE_DRAW = 1,
+	ALERT_TYPE_CHATRANGE = 2
+} ERadarAlertType;
+void chat_avatar_status(std::string name, LLUUID key, ERadarAlertType type, bool entering)
+{
+	if(gSavedSettings.getBOOL("RadarChatAlerts"))
+	{
+		LLChat chat;
+		switch(type)
+		{
+		case ALERT_TYPE_SIM:
+			if(gSavedSettings.getBOOL("RadarAlertSim"))
+			{
+				chat.mText = name+" has "+(entering ? "entered" : "left")+" the sim.";// ("+key.asString()+")";
+			}
+			break;
+		case ALERT_TYPE_DRAW:
+			if(gSavedSettings.getBOOL("RadarAlertDraw"))
+			{
+				chat.mText = name+" has "+(entering ? "entered" : "left")+" draw distance.";// ("+key.asString()+")";
+			}
+			break;
+		case ALERT_TYPE_CHATRANGE:
+			if(gSavedSettings.getBOOL("RadarAlertChatRange"))
+			{
+				chat.mText = name+" has "+(entering ? "entered" : "left")+" chat range.";// ("+key.asString()+")";
+			}
+			break;
+		}
+		if(!chat.mText.empty())
+		{
+			chat.mSourceType = CHAT_SOURCE_SYSTEM;
+			LLFloaterChat::addChat(chat);
+		}
+	}
+}
+
+void LLAvatarListEntry::setPosition(LLVector3d position, bool this_sim, bool drawn, bool chatrange)
+{
+	if ( drawn )
+	{
+	//	if ( mDrawPosition != position && !mDrawPosition.isExactlyZero() )
+		F32 threshold = gSavedSettings.getF32("RadarMovementThreshold");
+		if ( dist_vec(mDrawPosition,position) >  threshold && !mDrawPosition.isExactlyZero() )
+		{
+			setActivity(ACTIVITY_MOVING);
+		}
+
+		mDrawPosition = position;
+	} else if( mInDrawFrame == U32_MAX ) {
+		mDrawPosition.setZero();
+	}
+
+	mPosition = position;
+
+	mFrame = gFrameCount;
+	if(this_sim)
+	{
+		if(mInSimFrame == U32_MAX)
+		{
+			chat_avatar_status(mName,mID,ALERT_TYPE_SIM, true);
+			if(gSavedSettings.getBOOL("RadarChatKeys"))
+			{
+			 	LLMessageSystem* msg = gMessageSystem;
+			 	msg->newMessage("ScriptDialogReply");
+			 	msg->nextBlock("AgentData");
+			 	msg->addUUID("AgentID", gAgent.getID());
+			 	msg->addUUID("SessionID", gAgent.getSessionID());
+			 	msg->nextBlock("Data");
+			 	msg->addUUID("ObjectID", gAgent.getID());
+				//msg->addS32("ChatChannel", gSavedSettings.getString("RadarChatKeysChannel").asInteger());
+			 	msg->addS32("ChatChannel", gSavedSettings.getS32("RadarChatKeysChannel"));
+			 	msg->addS32("ButtonIndex", 1);
+			 	msg->addString("ButtonLabel",std::string("65337,19,") + mID.asString());
+				gAgent.sendReliableMessage();
+			}
+		}
+		mInSimFrame = mFrame;
+	}
+	if(drawn)
+	{
+		if(mInDrawFrame == U32_MAX)chat_avatar_status(mName,mID,ALERT_TYPE_DRAW, true);
+		mInDrawFrame = mFrame;
+	}
+	if(chatrange)
+	{
+		if(mInChatFrame == U32_MAX)chat_avatar_status(mName,mID,ALERT_TYPE_CHATRANGE, true);
+		mInChatFrame = mFrame;
+	}
+
+	mUpdateTimer.start();
+}
+
+LLVector3d LLAvatarListEntry::getPosition()
+{
+	return mPosition;
+}
+
+bool LLAvatarListEntry::getAlive()
+{
+	U32 current = gFrameCount;
+	if(mInSimFrame != U32_MAX && (current - mInSimFrame) >= 2)
+	{
+		mInSimFrame = U32_MAX;
+		chat_avatar_status(mName,mID,ALERT_TYPE_SIM, false);
+	}
+	if(mInDrawFrame != U32_MAX && (current - mInDrawFrame) >= 2)
+	{
+		mInDrawFrame = U32_MAX;
+		chat_avatar_status(mName,mID,ALERT_TYPE_DRAW, false);
+	}
+	if(mInChatFrame != U32_MAX && (current - mInChatFrame) >= 2)
+	{
+		mInChatFrame = U32_MAX;
+		chat_avatar_status(mName,mID,ALERT_TYPE_CHATRANGE, false);
+	}
+	return ((current - mFrame) <= 2);
+}
+//U32 LLAvatarListEntry::getOffSimFrames()
+//{
+//	return (gFrameCount - mInSimFrame);
+//}
+//U32 LLAvatarListEntry::getOffDrawFrames()
+//{
+//	return (gFrameCount - mInDrawFrame);
+//}
+//U32 LLAvatarListEntry::getOutsideChatRangeFrames();
+//{
+//	return (gFrameCount - mInChatFrame);
+//}
+
+F32 LLAvatarListEntry::getEntryAgeSeconds()
+{
+	return mUpdateTimer.getElapsedTimeF32();
+}
+
+void LLAvatarListEntry::setName(std::string name)
+{
+	if ( name.empty() || (name.compare(" ") == 0))
+	{
+		//llwarns << "Trying to set empty name" << llendl;
+	}
+	mName = name;
+}
+
+std::string LLAvatarListEntry::getName()
+{
+	return mName;
+}
+
+LLUUID LLAvatarListEntry::getID()
+{
+	return mID;
+}
+
+void LLAvatarListEntry::setID(LLUUID id)
+{
+	if ( id.isNull() )
+	{
+		llwarns << "Trying to set null id" << llendl;
+	}
+	mID = id;
+}
+
+BOOL LLAvatarListEntry::getIsLinden()
+{
+	// Are there any employees that are not a Linden?
+	// I suppose this is a bit redundant.
+	return ( mIsLinden || ( mAvatarInfo.getValue().Account == ACCOUNT_EMPLOYEE ) );
+}
+
+void LLAvatarListEntry::setAccountCustomTitle(std::string &title)
+{
+	mAccountTitle = title;
+	mAvatarInfo.getValue().Account = ACCOUNT_CUSTOM;
+}
+
+std::string LLAvatarListEntry::getAccountCustomTitle()
+{
+	return mAccountTitle;
+}
+
+
+
+void LLAvatarListEntry::setActivity(ACTIVITY_TYPE activity)
+{
+	if (activity == ACTIVITY_TYPING)
+	{
+		if ( activity >= mActivityType || mActivityTimer.getElapsedTimeF32() > ACTIVITY_TYPING_TIMEOUT )
+		{
+			mActivityType = activity;
+			mActivityTimer.start();
+		}
+
+	}else if ( activity >= mActivityType || mActivityTimer.getElapsedTimeF32() > ACTIVITY_TIMEOUT )
+	{
+		mActivityType = activity;
+		mActivityTimer.start();
+	}
+}
+
+ACTIVITY_TYPE LLAvatarListEntry::getActivity()
+{
+	if (mActivityType == ACTIVITY_TYPING)
+	{
+		if ( mActivityTimer.getElapsedTimeF32() > ACTIVITY_TYPING_TIMEOUT )
+		{
+			mActivityType = ACTIVITY_NONE;
+		}
+	}else if ( mActivityTimer.getElapsedTimeF32() > ACTIVITY_TIMEOUT )
+	{
+		mActivityType = ACTIVITY_NONE;
+	}
+	
+	return mActivityType;
+}
+
+void LLAvatarListEntry::toggleMark()
+{
+	mMarked = !mMarked;
+}
+
+BOOL LLAvatarListEntry::isMarked()
+{
+	return mMarked;
+}
+
+BOOL LLAvatarListEntry::isDead()
+{
+	return getEntryAgeSeconds() > DEAD_KEEP_TIME;
+}
+
+LLFloaterAvatarList* LLFloaterAvatarList::sInstance = NULL;
+
+LLFloaterAvatarList::LLFloaterAvatarList() :  LLFloater(std::string("avatar list"))
+{
+	llassert_always(sInstance == NULL);
+	sInstance = this;
+}
+
+LLFloaterAvatarList::~LLFloaterAvatarList()
+{
+	gIdleCallbacks.deleteFunction( LLFloaterAvatarList::callbackIdle );
+	sInstance = NULL;
+}
+
+//static
+void LLFloaterAvatarList::toggle(void*)
+{
+	if (sInstance)
+	{
+		if(sInstance->getVisible())
+		{
+			sInstance->close(false);
+		}
+		else
+		{
+			sInstance->open();
+		}
+	}
+	else
+	{
+		showInstance();
+	}
+}
+
+//static
+void LLFloaterAvatarList::showInstance()
+{
+	if (sInstance)
+	{
+		if(!sInstance->getVisible())
+		{
+			sInstance->open();
+		}
+	}
+	else
+	{
+		sInstance = new LLFloaterAvatarList();
+		LLUICtrlFactory::getInstance()->buildFloater(sInstance, "floater_avatar_scanner.xml");
+	}
+}
+
+void LLFloaterAvatarList::draw()
+{
+	LLFloater::draw();
+}
+
+void LLFloaterAvatarList::onOpen()
+{
+	gSavedSettings.setBOOL("ShowAvatarList", TRUE);
+	sInstance->setVisible(TRUE);
+}
+
+void LLFloaterAvatarList::onClose(bool app_quitting)
+{
+	sInstance->setVisible(FALSE);
+	if( !app_quitting )
+	{
+		gSavedSettings.setBOOL("ShowAvatarList", FALSE);
+	}
+	if ( !gSavedSettings.getBOOL("AvatarListKeepOpen") || app_quitting )
+	{
+		destroy();
+	}
+}
+
+BOOL LLFloaterAvatarList::postBuild()
+{
+	{
+		LLTabContainer* tab = getChild<LLTabContainer>("actions_tab_container");
+
+		if(tab)
+		{
+			LLPanel* panel = tab->getPanelByName("custom_tab");
+
+			if(panel)
+			{
+				tab->enableTabButton(tab->getIndexForPanel(panel), FALSE);
+			}
+		}
+	}
+
+	// Default values
+	mTracking = FALSE;
+	mTrackByLocation = FALSE;
+	mARLastFrame = 0;
+
+	// Create interface from XML
+	//gUICtrlFactory->buildFloater(this, "floater_avatar_scanner.xml");
+
+	// Floater starts hidden	
+	//setVisible(FALSE);
+
+	// Hide them until some other way is found
+	// Users may not expect to find a Ban feature on the Eject button
+	childSetVisible("refresh_btn", false);
+	childSetVisible("ban_btn", false);
+	childSetVisible("unban_btn", false);
+	//childSetVisible("unmute_btn", false);
+	childSetVisible("estate_ban_btn", false);
+
+	// Set callbacks
+	//childSetAction("refresh_btn", onClickRefresh, this);
+	childSetAction("profile_btn", onClickProfile, this);
+	childSetAction("im_btn", onClickIM, this);
+	childSetAction("track_btn", onClickTrack, this);
+	childSetAction("mark_btn", onClickMark, this);
+
+	childSetAction("prev_in_list_btn", onClickPrevInList, this);
+	childSetAction("next_in_list_btn", onClickNextInList, this);
+	childSetAction("prev_marked_btn", onClickPrevMarked, this);
+	childSetAction("next_marked_btn", onClickNextMarked, this);
+	
+	childSetAction("get_key_btn", onClickGetKey, this);
+
+	childSetAction("freeze_btn", onClickFreeze, this);
+	childSetAction("eject_btn", onClickEject, this);
+//	childSetAction("ban_btn", onClickBan, this);
+//	childSetAction("unban_btn", onClickUnban, this);
+	childSetAction("mute_btn", onClickMute, this);
+	childSetAction("unmute_btn", onClickUnmute, this);
+	childSetAction("ar_btn", onClickAR, this);
+	childSetAction("teleport_btn", onClickTeleport, this);
+	childSetAction("estate_eject_btn", onClickEjectFromEstate, this);
+
+	// *FIXME: Uncomment once onClickRefresh has been restored
+	//setDefaultBtn("refresh_btn");
+
+	// Get a pointer to the scroll list from the interface
+	mAvatarList = getChild<LLScrollListCtrl>("avatar_list");
+
+	mAvatarList->setCallbackUserData(this);
+	mAvatarList->setDoubleClickCallback(onDoubleClick);
+	mAvatarList->sortByColumn("distance", TRUE);
+	mDataRequestTimer.start();
+	refreshAvatarList();
+
+	//LLMessageSystem *msg = gMessageSystem;
+	//msg->addHandlerFunc("AvatarPropertiesReply", processAvatarPropertiesReply);
+
+	gIdleCallbacks.addFunction( LLFloaterAvatarList::callbackIdle );
+
+	return TRUE;
+}
+
+void LLFloaterAvatarList::updateAvatarList()
+{
+//	LLVOAvatar *avatarp;
+
+	if( sInstance != this ) return;
+
+	//llinfos << "avatar list refresh: updating map" << llendl;
+
+	// Check whether updates are enabled
+	LLCheckboxCtrl* check;
+	check = getChild<LLCheckboxCtrl>("update_enabled_cb");
+
+	if ( !check->getValue() )
+	{
+		return;
+	}
+
+	LLVector3d mypos = gAgent.getPositionGlobal();
+
+	{//iterate minimap so if they are within draw the more precise value ends up used
+		// Draw avatars
+		//const LLVector3d& my_origin_global = gAgent.getRegion()->getOriginGlobal();
+		LLVector3d pos_global;
+		for (LLWorld::region_list_t::iterator iter = LLWorld::getInstance()->mActiveRegionList.begin();
+			 iter != LLWorld::getInstance()->mActiveRegionList.end(); ++iter)
+		{
+			LLViewerRegion* regionp = *iter;
+			const LLVector3d& origin_global = regionp->getOriginGlobal();
+
+			S32 count = regionp->mMapAvatars.count();
+			S32 i;
+			LLVector3 pos_local;
+			U32 compact_local;
+			U8 bits;
+			for (i = 0; i < count; i++)
+			{
+				compact_local = regionp->mMapAvatars.get(i);
+
+				bits = compact_local & 0xFF;
+				pos_local.mV[VZ] = F32(bits) * 4.f;
+				compact_local >>= 8;
+
+				bits = compact_local & 0xFF;
+				pos_local.mV[VY] = (F32)bits;
+				compact_local >>= 8;
+
+				bits = compact_local & 0xFF;
+				pos_local.mV[VX] = (F32)bits;
+
+				pos_global.setVec( pos_local );
+				pos_global += origin_global;
+
+				if( i < regionp->mMapAvatarIDs.count())
+				{
+					std::string name;
+					std::string first;
+					std::string last;
+					LLUUID avid = regionp->mMapAvatarIDs.get(i);
+					gCacheName->getName(avid, first, last);
+					name=  first+" "+last;
+					LLVector3d position = pos_global;
+					if (name.empty() || (name.compare(" ") == 0) || first == gCacheName->getDefaultName())
+					{
+						//llinfos << "Name empty for avatar " << avid << llendl;
+						continue;
+					}
+					if( pos_global.mdV[VZ] == 0.0)
+					{
+						//bad hax :<
+						//uhh... >.>  i am going to play with this at the display part... yeah
+					}
+
+					if (avid.isNull())
+					{
+						//llinfos << "Key empty for avatar " << name << llendl;
+						continue;
+					}
+
+					if ( mAvatars.count( avid ) > 0 )
+					{
+						// Avatar already in list, update position
+						mAvatars[avid].setPosition(position, (regionp == gAgent.getRegion()), false, (position - mypos).magVec() < 20.0);
+					}
+					else
+					{
+						// Avatar not there yet, add it
+						BOOL isLinden = last == "Linden"; 
+						/*for triggering a "omg a linden - RUN" gesture or  
+						what is that good for?*/
+
+						LLAvatarListEntry entry(avid, name, position, isLinden);
+						mAvatars[avid] = entry;
+
+						//sendAvatarPropertiesRequest(avid);
+						//llinfos << "avatar list refresh: adding " << name << llendl;
+
+					}
+
+					//if(mAreaAlertList.count( avid ) > 0 )
+					//{
+						
+						//if(mAreaAlertList[avid].area < 1)
+						//{
+						//	mAreaAlertList[avid].area = 1;
+					//		LLChat chat;
+					//		chat.mSourceType = CHAT_SOURCE_SYSTEM;
+					//		chat.mText = 
+						//}
+						//
+					//}
+					
+				}
+			}
+		}
+	}
+	/*
+	 * Iterate over all the avatars known at the time
+	 * NOTE: Is this the right way to do that? It does appear that LLVOAvatar::isInstances contains
+	 * the list of avatars known to the client. This seems to do the task of tracking avatars without
+	 * any additional requests.
+	 *
+	 * BUG: It looks like avatars sometimes get stuck in this list, and keep perpetually
+	 * moving in the same direction. My current guess is that somewhere else the client
+	 * doesn't notice an avatar disappeared, and keeps updating its position. This should
+	 * be solved at the source of the problem.
+	 */
+	for (std::vector<LLCharacter*>::iterator iter = LLCharacter::sInstances.begin();
+		iter != LLCharacter::sInstances.end(); ++iter)
+	{
+		LLVOAvatar* avatarp = (LLVOAvatar*) *iter;
+
+		// Skip if avatar is dead(what's that?)
+		// or if the avatar is ourselves.
+		if (avatarp->isDead() || avatarp->isSelf())
+		{
+			continue;
+		}
+
+		// Get avatar data
+		LLVector3d position = gAgent.getPosGlobalFromAgent(avatarp->getCharacterPosition());
+		LLUUID avid = avatarp->getID();
+		std::string name = avatarp->getFullname();
+
+		// Apparently, sometimes the name comes out empty, with a " " name. This is because
+		// getFullname concatenates first and last name with a " " in the middle.
+		// This code will avoid adding a nameless entry to the list until it acquires a name.
+
+		//duped for lower section
+		if (name.empty() || (name.compare(" ") == 0))// || (name.compare(gCacheName->getDefaultName()) == 0))
+		{
+			//llinfos << "Name empty for avatar " << avid << llendl;
+			continue;
+		}
+
+		if (avid.isNull())
+		{
+			//llinfos << "Key empty for avatar " << name << llendl;
+			continue;
+		}
+
+		if ( mAvatars.count( avid ) > 0 )
+		{
+			// Avatar already in list, update position
+			mAvatars[avid].setPosition(position, (avatarp->getRegion() == gAgent.getRegion()), true, (position - mypos).magVec() < 20.0);
+		}
+		else
+		{
+			// Avatar not there yet, add it
+			BOOL isLinden = ( avatarp->getNVPair("LastName")->getString() == std::string("Linden") );
+
+			LLAvatarListEntry entry(avid, name, position, isLinden);
+			mAvatars[avid] = entry;
+
+			//sendAvatarPropertiesRequest(avid);
+			//llinfos << "avatar list refresh: adding " << name << llendl;
+
+		}
+	}
+
+//	llinfos << "avatar list refresh: done" << llendl;
+
+	expireAvatarList();
+	refreshAvatarList();
+	checkTrackingStatus();
+	//processARQueue();
+}
+
+void LLFloaterAvatarList::expireAvatarList()
+{
+//	llinfos << "avatar list: expiring" << llendl;
+	std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+	std::queue<LLUUID> delete_queue;
+
+	for(iter = mAvatars.begin(); iter != mAvatars.end(); iter++)
+	{
+		LLAvatarListEntry *ent = &iter->second;
+		
+		if ( !ent->getAlive())
+		{
+			ent->setActivity(ACTIVITY_DEAD);
+		}
+
+
+		if ( ent->getEntryAgeSeconds() > CLEANUP_TIMEOUT )
+		{
+			//llinfos << "avatar list: expiring avatar " << ent->getName() << llendl;
+			LLUUID av_id = ent->getID();
+			delete_queue.push(av_id);
+		}
+	}
+
+	while(!delete_queue.empty())
+	{
+		mAvatars.erase(delete_queue.front());
+		delete_queue.pop();
+	}
+}
+
+/**
+ * Redraws the avatar list
+ * Only does anything if the avatar list is visible.
+ * @author Dale Glass
+ */
+void LLFloaterAvatarList::refreshAvatarList() 
+{
+
+
+	// Don't update list when interface is hidden
+	if (!sInstance->getVisible())return;
+
+	LLCheckboxCtrl* fetch_data;
+	fetch_data = getChild<LLCheckboxCtrl>("fetch_avdata_enabled_cb");
+
+	//BOOL db_enabled = gSavedSettings.getBOOL("DBEnabled");
+	//std::string db_avatar = gSavedPerAccountSettings.getString("DBAvatarName");
+	//if ( db_avatar.empty() )
+	//{
+	//	db_enabled = FALSE;
+	//}
+
+
+
+	// We rebuild the list fully each time it's refreshed
+	// The assumption is that it's faster to refill it and sort than
+	// to rebuild the whole list.
+	LLDynamicArray<LLUUID> selected = mAvatarList->getSelectedIDs();
+	S32 scrollpos = mAvatarList->getScrollPos();
+
+	mAvatarList->deleteAllItems();
+
+	LLVector3d mypos = gAgent.getPositionGlobal();
+
+
+	std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+	for(iter = mAvatars.begin(); iter != mAvatars.end(); iter++)
+	{
+		LLSD element;
+		LLUUID av_id;
+
+		
+		LLAvatarListEntry *ent = &iter->second;
+
+		// Skip if avatar hasn't been around
+		if ( ent->isDead() )
+		{
+			continue;
+		}
+
+		av_id = ent->getID();
+
+		// Get avatar name, position
+		LLAvatarInfo avinfo = ent->mAvatarInfo.getValue();
+		//LLAvListTrustNetScore avscore = ent->mTrustNetScore.getValue();
+
+		DATA_STATUS avinfo_status = ent->mAvatarInfo.getStatus();
+		//DATA_STATUS avscore_status = ent->mTrustNetScore.getStatus();
+
+		LLVector3d position = ent->getPosition();
+		//lgg stuff.. ok.. uhmm..
+		BOOL flagForFedUpDistance = false;
+
+		
+		LLVector3d delta = position - mypos;
+		F32 distance = (F32)delta.magVec();
+		if(position.mdV[VZ] == 0.0)
+		{
+			flagForFedUpDistance = true;
+			distance = 9000;
+		}
+		delta.mdV[2] = 0.0f;
+		F32 side_distance = (F32)delta.magVec();
+
+		std::string icon = "";
+
+		// HACK: Workaround for an apparent bug:
+		// sometimes avatar entries get stuck, and are registered
+		// by the client as perpetually moving in the same direction.
+		// this makes sure they get removed from the visible list eventually
+
+		//jcool410 -- this fucks up seeing dueds thru minimap data > 1024m away, so, lets just say > 2048m to the side is bad
+		//aka 8 sims
+		if ( side_distance > 2048.0f)
+		{
+			continue;
+		}
+
+		if ( av_id.isNull() )
+		{
+			//llwarns << "Avatar with null key somehow got into the list!" << llendl;
+			continue;
+		}
+
+
+
+
+
+		element["id"] = av_id;
+
+		element["columns"][LIST_AVATAR_ICON]["column"] = "avatar_icon";
+		element["columns"][LIST_AVATAR_ICON]["type"] = "text";
+		if ( ent->isMarked() )
+		{
+			element["columns"][LIST_AVATAR_ICON]["type"] = "icon";
+			element["columns"][LIST_AVATAR_ICON]["value"] = /*gViewerArt.getString(*/"flag_blue.tga"/*)*/;
+		}
+
+
+		if ( ent->getIsLinden() )
+		{
+			element["columns"][LIST_AVATAR_NAME]["font-style"] = "BOLD";
+		}
+
+		if ( ent->isFocused() )
+		{
+			element["columns"][LIST_AVATAR_NAME]["color"] = LLColor4::cyan.getValue();
+		}
+
+		//element["columns"][LIST_AVATAR_NAME]["font-color"] = getAvatarColor(ent, distance).getValue();
+		element["columns"][LIST_AVATAR_NAME]["column"] = "avatar_name";
+		element["columns"][LIST_AVATAR_NAME]["type"] = "text";
+		element["columns"][LIST_AVATAR_NAME]["value"] = ent->getName().c_str();
+
+		char temp[32];
+		snprintf(temp, sizeof(temp), "%.2f", distance);
+
+		element["columns"][LIST_DISTANCE]["column"] = "distance";
+		element["columns"][LIST_DISTANCE]["type"] = "text";
+		
+		element["columns"][LIST_DISTANCE]["value"] = temp;
+		if(flagForFedUpDistance)
+		{
+			//lgg fix for out of draw distance
+			//element["columns"][LIST_DISTANCE]["value"] = std::string("(> "+llformat("%d", gSavedSettings.getF32("RenderFarClip") )+")");
+			element["columns"][LIST_DISTANCE]["value"] = llformat("> %d", (S32)gSavedSettings.getF32("RenderFarClip") );
+		}
+		element["columns"][LIST_DISTANCE]["color"] = getAvatarColor(ent, distance, CT_DISTANCE).getValue();
+
+		
+		if ( avinfo_status == DATA_RETRIEVED )
+		{
+			element["columns"][LIST_AGE]["column"] = "age";
+			element["columns"][LIST_AGE]["type"] = "text";
+			element["columns"][LIST_AGE]["value"] = avinfo.getAge();
+			element["columns"][LIST_AGE]["color"] = getAvatarColor(ent, distance, CT_AGE).getValue();
+		}
+
+		//element["columns"][LIST_SCORE]["column"] = "score";
+		//element["columns"][LIST_SCORE]["type"] = "text";
+
+		//icon = "";
+		//switch(avscore_status)
+		//{
+		//	case DATA_UNKNOWN:
+		//		icon = /*gViewerArt.getString(*/"info_unknown.tga"/*)*/;
+		//		break;
+		//	case DATA_REQUESTING:
+		//		icon = /*gViewerArt.getString(*/"info_fetching.tga"/*)*/;
+		//		break;
+		//	case DATA_ERROR:
+		//		icon =  /*gViewerArt.getString(*/"info_error.tga"/*)*/;
+		//	case DATA_RETRIEVED:
+		//		//element["columns"][LIST_SCORE]["value"] = avscore.Score;
+		//		element["columns"][LIST_SCORE]["color"] = getAvatarColor(ent, distance, CT_SCORE).getValue();
+		//		break;
+		//}
+		
+		//if (!icon.empty() )
+		//{	
+		//	element["columns"][LIST_SCORE].erase("color");
+		//	element["columns"][LIST_SCORE]["type"] = "icon";
+		//	element["columns"][LIST_SCORE]["value"] = icon;
+		//}
+	
+
+		// Get an icon for the payment data
+		// These should be replaced with something proper instead of reusing whatever
+		// LL-provided images happened to fit
+		icon = "";
+
+		switch(avinfo_status)
+		{
+			case DATA_UNKNOWN:
+				icon = /*gViewerArt.getString(*/"info_unknown.tga"/*)*/;
+				break;
+			case DATA_REQUESTING:
+				icon = /*gViewerArt.getString(*/"info_fetching.tga"/*)*/;
+				break;
+			case DATA_ERROR:
+				icon =  /*gViewerArt.getString(*/"info_error.tga"/*)*/;
+				break;
+			case DATA_RETRIEVED:
+				switch(avinfo.Payment)
+				{
+					case PAYMENT_NONE:
+						break;
+					case PAYMENT_ON_FILE:
+						icon =  /*gViewerArt.getString(*/"payment_info_filled.tga"/*)*/;
+						break;
+					case PAYMENT_USED:
+						icon =  /*gViewerArt.getString(*/"payment_info_used.tga"/*)*/;
+						break;
+					case PAYMENT_LINDEN:
+						// confusingly named icon, maybe use something else
+						icon =  /*gViewerArt.getString(*/"icon_top_pick.tga"/*)*/;
+						break;
+				}
+				break;
+		}
+
+		element["columns"][LIST_PAYMENT]["column"] = "payment_data";
+		element["columns"][LIST_PAYMENT]["type"] = "text";
+
+		// TODO: Add icon for "unknown" status
+		//if ( PAYMENT_NONE != avinfo.Payment && DATA_UNKNOWN != avinfo_status )
+		if ( !icon.empty() )
+		{
+			element["columns"][LIST_PAYMENT].erase("color");
+			element["columns"][LIST_PAYMENT]["type"] = "icon";
+			element["columns"][LIST_PAYMENT]["value"] =  icon;
+			//llinfos << "Payment icon: " << payment_icon << llendl;
+		}
+
+		
+		ACTIVITY_TYPE activity = ent->getActivity();
+		icon = "";
+		switch( activity )
+		{
+			case ACTIVITY_NONE:
+				break;
+			case ACTIVITY_MOVING:
+				icon = /*gViewerArt.getString(*/"inv_item_animation.tga"/*)*/;
+				break;
+			case ACTIVITY_GESTURING:
+				icon = /*gViewerArt.getString(*/"inv_item_gesture.tga"/*)*/;
+				break;
+			case ACTIVITY_TYPING:
+				icon = /*gViewerArt.getString(*/"avatar_typing.tga"/*)*/;
+				break;
+			case ACTIVITY_SOUND:
+				icon = /*gViewerArt.getString(*/"avatar_sound.tga"/*)*/;
+				break;
+			case ACTIVITY_REZZING:
+				icon = /*gViewerArt.getString(*/"ff_edit_theirs.tga"/*)*/;
+				break;
+			case ACTIVITY_PARTICLES:
+				// TODO: Replace with something better
+				icon = /*gViewerArt.getString(*/"avatar_particles.tga"/*)*/;
+				break;
+			case ACTIVITY_NEW:
+				icon = /*gViewerArt.getString(*/"avatar_new.tga"/*)*/;
+				break;
+			case ACTIVITY_DEAD:
+				// TODO: Replace, icon is quite inappropiate
+				icon = /*gViewerArt.getString(*/"avatar_gone.tga"/*)*/;
+				break;
+		}
+
+		element["columns"][LIST_ACTIVITY]["column"] = "activity";
+		element["columns"][LIST_ACTIVITY]["type"] = "text";
+
+		if (!icon.empty() )
+		{	
+			element["columns"][LIST_ACTIVITY]["type"] = "icon";
+			element["columns"][LIST_ACTIVITY]["value"] = icon;
+			//llinfos << "Activity icon: " << activity_icon << llendl;
+		}
+
+		//element["columns"][LIST_PAYMENT]["column"] = "payment_data";
+		//element["columns"][LIST_PAYMENT]["type"] = "text";
+
+		element["columns"][LIST_CLIENT]["column"] = "client";
+		element["columns"][LIST_CLIENT]["type"] = "text";
+		LLColor4 avatar_name_color = gColors.getColor( "AvatarNameColor" );
+		std::string client;
+		LLVOAvatar *av = (LLVOAvatar*)gObjectList.findObject(av_id);
+		if(av)
+		{
+			LLVOAvatar::resolveClient(avatar_name_color, client, av);
+			if(client.empty())
+			{
+				avatar_name_color = gColors.getColor( "ScrollUnselectedColor" );
+				client = "?";
+			}
+			element["columns"][LIST_CLIENT]["value"] = client.c_str();
+		}
+		else
+		{
+			element["columns"][LIST_CLIENT]["value"] = "Out Of Range";
+			avatar_name_color = gColors.getColor( "ScrollUnselectedColor" );
+		}
+		avatar_name_color = avatar_name_color * 0.5 + gColors.getColor( "ScrollUnselectedColor" ) * 0.5;
+		element["columns"][LIST_CLIENT]["color"] = avatar_name_color.getValue();
+		
+
+		// Add to list
+		mAvatarList->addElement(element, ADD_BOTTOM);
+
+		// Request data only if fetching avatar data is enabled
+		if ( fetch_data->getValue() && ent->mAvatarInfo.requestIfNeeded() )
+		{
+			sendAvatarPropertiesRequest(av_id);
+			//llinfos << "Data for avatar " << ent->getName() << " didn't arrive yet, retrying" << llendl;
+		}
+
+/*		if ( ent->mTrustNetScore.requestIfNeeded() )
+		{
+			requestTrustNetScore(av_id, ent->getName(), "behavior");
+			llinfos << "Requesting TrustNet score for " << ent->getName() << llendl;
+		}*/
+		
+		/*if ( db_enabled && ent->mMiscInfo.requestIfNeeded() )
+		{
+			requestMiscInfo(av_id, ent->getName());
+			llinfos << "Requesting misc info for " << ent->getName() << llendl;
+		}*/
+	}
+
+	// finish
+	mAvatarList->sortItems();
+	mAvatarList->selectMultiple(selected);
+	mAvatarList->setScrollPos(scrollpos);
+
+//	llinfos << "avatar list refresh: done" << llendl;
+
+}
+
+// static
+void LLFloaterAvatarList::onClickIM(void* userdata)
+{
+	//llinfos << "LLFloaterFriends::onClickIM()" << llendl;
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+
+	LLDynamicArray<LLUUID> ids = avlist->mAvatarList->getSelectedIDs();
+	if(ids.size() > 0)
+	{
+		if(ids.size() == 1)
+		{
+			// Single avatar
+			LLUUID agent_id = ids[0];
+
+			char buffer[MAX_STRING];
+			snprintf(buffer, MAX_STRING, "%s", avlist->mAvatars[agent_id].getName().c_str());
+			gIMMgr->setFloaterOpen(TRUE);
+			gIMMgr->addSession(
+				buffer,
+				IM_NOTHING_SPECIAL,
+				agent_id);
+		}
+		else
+		{
+			// Group IM
+			LLUUID session_id;
+			session_id.generate();
+			gIMMgr->setFloaterOpen(TRUE);
+			gIMMgr->addSession("Avatars Conference", IM_SESSION_CONFERENCE_START, ids[0], ids);
+		}
+	}
+}
+
+void LLFloaterAvatarList::onClickTrack(void *userdata)
+{
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+	
+ 	LLScrollListItem *item =   avlist->mAvatarList->getFirstSelected();
+	if (!item) return;
+
+	LLUUID agent_id = item->getUUID();
+
+	if ( avlist->mTracking && avlist->mTrackedAvatar == agent_id ) {
+		LLTracker::stopTracking(NULL);
+		avlist->mTracking = FALSE;
+	}
+	else
+	{
+		avlist->mTracking = TRUE;
+		avlist->mTrackByLocation = FALSE;
+		avlist->mTrackedAvatar = agent_id;
+		LLTracker::trackAvatar(agent_id, avlist->mAvatars[agent_id].getName());
+	}
+}
+
+void LLFloaterAvatarList::sendAvatarPropertiesRequest(LLUUID avid)
+{
+	
+
+	lldebugs << "LLPanelAvatar::sendAvatarPropertiesRequest()" << llendl; 
+	LLMessageSystem *msg = gMessageSystem;
+
+	msg->newMessageFast(_PREHASH_AvatarPropertiesRequest);
+	msg->nextBlockFast( _PREHASH_AgentData);
+	msg->addUUIDFast(   _PREHASH_AgentID, gAgent.getID() );
+	msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+	msg->addUUIDFast(   _PREHASH_AvatarID, avid);
+	gAgent.sendReliableMessage();
+
+	mAvatars[avid].mAvatarInfo.requestStarted();
+}
+
+// static
+void LLFloaterAvatarList::processAvatarPropertiesReply(LLMessageSystem *msg, void**)
+{
+
+	if(!sInstance)return;
+
+	LLFloaterAvatarList* self = NULL;
+	LLAvatarInfo avinfo;
+
+	BOOL	identified = FALSE;
+	BOOL	transacted = FALSE;
+
+	LLUUID	agent_id;	// your id
+	LLUUID	avatar_id;	// target of this panel
+	U32	flags = 0x0;
+	char	born_on[DB_BORN_BUF_SIZE];
+	S32	charter_member_size = 0;
+
+	msg->getUUIDFast(_PREHASH_AgentData, _PREHASH_AgentID, agent_id);
+	msg->getUUIDFast(_PREHASH_AgentData, _PREHASH_AvatarID, avatar_id );
+
+	
+	self = sInstance;
+
+	// Verify that the avatar is in the list, if not, ignore.
+	if ( self->mAvatarList->getItemIndex(avatar_id) < 0 )
+	{
+		return;
+	}
+
+	LLAvatarListEntry *entry = &self->mAvatars[avatar_id];
+
+	msg->getStringFast(_PREHASH_PropertiesData, _PREHASH_BornOn, DB_BORN_BUF_SIZE, born_on);
+	msg->getU32Fast(_PREHASH_PropertiesData, _PREHASH_Flags, flags);
+
+	identified = (flags & AVATAR_IDENTIFIED);
+	transacted = (flags & AVATAR_TRANSACTED);
+
+	// What's this?
+	// Let's see if I understand correctly: CharterMember property is dual purpose:
+	// it either contains a number indicating an account type (usual value), or 
+	// it contains a string with a custom title. Probably that's where Philip Linden's
+	// "El Presidente" title comes from. Heh.
+	U8 caption_index = 0;
+	std::string caption_text;
+	charter_member_size = msg->getSize("PropertiesData", "CharterMember");
+
+	if(1 == charter_member_size)
+	{
+		msg->getBinaryData("PropertiesData", "CharterMember", &caption_index, 1);
+	}
+	else if(1 < charter_member_size)
+	{
+		char caption[MAX_STRING];
+		msg->getString("PropertiesData", "CharterMember", MAX_STRING, caption);
+
+		caption_text = caption;
+		entry->setAccountCustomTitle(caption_text);
+	}
+		
+
+	if(caption_text.empty())
+	{
+		
+		const enum ACCOUNT_TYPE ACCT_TYPE[] = {
+			ACCOUNT_RESIDENT,
+			ACCOUNT_TRIAL,
+			ACCOUNT_CHARTER_MEMBER,
+			ACCOUNT_EMPLOYEE
+		};
+
+		//enum ACCOUNT_TYPE acct =
+		avinfo.Account =  ACCT_TYPE[llclamp(caption_index, (U8)0, (U8)(sizeof(ACCT_TYPE)/sizeof(ACCT_TYPE[0])-1))];
+		//entry->setAccountType(acct);
+
+		
+		if ( avinfo.Account != ACCOUNT_EMPLOYEE )
+		{
+			if ( transacted )
+			{
+				avinfo.Payment = PAYMENT_USED;
+			}
+			else if ( identified )
+			{
+				avinfo.Payment = PAYMENT_ON_FILE;
+			}
+			else
+			{
+				avinfo.Payment = PAYMENT_NONE;
+			}
+		}
+		else
+		{
+			avinfo.Payment = PAYMENT_LINDEN;
+		}
+	}
+	
+	// Structure must be zeroed to have sane results, as we
+	// have an incomplete string for input
+	memset(&avinfo.BirthDate, 0, sizeof(avinfo.BirthDate));
+
+	int num_read = sscanf(born_on, "%d/%d/%d", &avinfo.BirthDate.tm_mon,
+	                                           &avinfo.BirthDate.tm_mday,
+	                                           &avinfo.BirthDate.tm_year);
+
+	if ( num_read == 3 && avinfo.BirthDate.tm_mon <= 12 )
+	{
+		avinfo.BirthDate.tm_year -= 1900;
+		avinfo.BirthDate.tm_mon--;
+	}
+	else
+	{
+		// Zero again to remove any partially read data
+		memset(&avinfo.BirthDate, 0, sizeof(avinfo.BirthDate));
+		llwarns << "Error parsing birth date: " << born_on << llendl;
+	}
+
+	entry->mAvatarInfo.setValue(avinfo);
+}
+
+void LLFloaterAvatarList::checkTrackingStatus()
+{
+
+	if ( mTracking && LLTracker::getTrackedPositionGlobal().isExactlyZero() )
+	{
+		// trying to track an avatar, but tracker stopped tracking		
+		if ( mAvatars.count( mTrackedAvatar ) > 0 && !mTrackByLocation )
+		{
+			llinfos << "Switching to location-based tracking" << llendl;
+			mTrackByLocation = TRUE;
+		}
+		else
+		{
+			// not found
+			llinfos << "Stopping tracking avatar, server-side didn't work, and not in list anymore." << llendl;
+			LLTracker::stopTracking(NULL);
+			mTracking = FALSE;
+		}
+	}
+
+	if ( mTracking && mTrackByLocation )
+	{
+		std::string name = mAvatars[mTrackedAvatar].getName();
+		std::string tooltip = "Tracking last known position";
+		name += " (near)";
+		LLTracker::trackLocation(mAvatars[mTrackedAvatar].getPosition(), name, tooltip);
+	}
+
+	//llinfos << "Tracking position: " << LLTracker::getTrackedPositionGlobal() << llendl;
+	
+}
+
+
+BOOL  LLFloaterAvatarList::avatarIsInList(LLUUID avatar)
+{
+	return ( mAvatars.count( avatar ) > 0 );
+}
+
+LLAvatarListEntry * LLFloaterAvatarList::getAvatarEntry(LLUUID avatar)
+{
+	if ( avatar.isNull() )
+	{
+		return NULL;
+	}
+
+	std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+
+	iter = mAvatars.find(avatar);
+	if ( iter == mAvatars.end() )
+	{
+		return NULL;
+	}
+
+	return &iter->second;	
+	
+	//if ( mAvatars.count( avatar ) < 0 )
+	//{
+		//return NULL;
+	//}
+
+	//return &mAvatars[avatar];
+}
+/*
+void LLFloaterAvatarList::speakText(S32 channel, EChatType type, std::string text)
+{
+	LLMessageSystem* msg = gMessageSystem;
+
+	msg->newMessageFast(_PREHASH_ChatFromViewer);
+	msg->nextBlockFast(_PREHASH_AgentData);
+	msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
+	msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+	msg->nextBlockFast(_PREHASH_ChatData);
+	msg->addStringFast(_PREHASH_Message, text);
+	msg->addU8Fast(_PREHASH_Type, type);
+	msg->addS32("Channel", channel);
+
+	gAgent.sendReliableMessage();
+
+	gViewerStats->incStat(LLViewerStats::ST_CHAT_COUNT);
+}
+*/
+/*
+void LLFloaterAvatarList::requestTrustNetScore(LLUUID avatar, const std::string name, const std::string type)
+{
+	char *temp = new char[UUID_STR_LENGTH];
+	avatar.toString(temp);
+
+	std::string text = "GetScore|" + name + "|" + temp + "|" + type;
+	speakText(TRUSTNET_CHANNEL, CHAT_TYPE_WHISPER, text);
+}
+*/
+//static
+/*
+void LLFloaterAvatarList::replaceVars(std::string &str, LLUUID avatar, const std::string& name)
+{
+	char *temp = new char[UUID_STR_LENGTH];
+	avatar.toString(temp);
+
+	std::string vars[][2] = {
+		{"$NAME", name},
+		{"$KEY",  temp},
+	};
+
+	BOOL replaced = TRUE;
+
+	while( replaced )
+	{
+		replaced = FALSE;
+		for(U32 i=0;i<sizeof(vars)/sizeof(vars[0]);i++)
+		{
+			U32 pos = str.find(vars[i][0]);
+			if ( pos != std::string::npos )
+			{
+				str.replace(pos, vars[i][0].size(), vars[i][1]);
+				replaced = TRUE;
+			}
+		}
+	}
+
+}
+
+void LLFloaterAvatarList::requestMiscInfo(LLUUID avatar, const std::string name)
+{
+	LLUUID   db_av_key;
+
+	std::string message      = gSavedPerAccountSettings.getString("DBSendPattern");
+	std::string db_av_name   = gSavedPerAccountSettings.getString("DBAvatarName");
+	db_av_key.set(gSavedPerAccountSettings.getString("DBAvatarKey"));
+
+	
+	llinfos << "Requesting info " << llendl;
+	replaceVars(message, avatar, name);
+
+	llinfos << "Request string: " << message << llendl;
+	send_simple_im(db_av_key, message.c_str());
+ }
+
+//static
+BOOL LLFloaterAvatarList::handleIM(LLUUID from_id, const std::string message)
+{
+	LLUUID   db_av_key;
+	db_av_key.set(gSavedPerAccountSettings.getString("DBAvatarKey"));
+
+	if ( db_av_key == from_id )
+	{
+		std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+
+		for(iter = sInstance->mAvatars.begin(); iter != sInstance->mAvatars.end(); iter++)
+		{
+			LLAvatarListEntry *ent = &iter->second;
+		
+			// Check if the key, or the name are found in the reply.
+			// Name is only accepted if it's in the beginning of the message.
+			if ( message.find(ent->getID().asString()) != std::string::npos
+			     || message.find(ent->getName().c_str()) == 0 )
+			{
+				LLMiscDBInfo info;
+				info.data = message;
+
+				llinfos << "Database reply arrived for avatar " << ent->getName() << llendl;
+				ent->mMiscInfo.setValue(info);
+			}
+		}
+
+		return TRUE;
+	}
+	return FALSE;
+}
+*/
+//static
+/*void LLFloaterAvatarList::processTrustNetReply(char *reply)
+{
+	char *tokens[10];
+	char *tmp = &reply[0];
+	U32 count = 0;
+
+	llinfos << "TrustNet reply: " << reply << llendl;
+	
+
+	// Split into tokens
+	while( (NULL != (tmp = strtok(tmp, "|"))) && count < (sizeof(tokens)/sizeof(tokens[0])) )
+	{
+		tokens[count++] = tmp;
+		llinfos << "token: " << tmp << llendl;
+		tmp = NULL;
+	}
+
+	llinfos << "Got " << count << " tokens" << llendl;
+
+	if ( count >= 1 )
+	{
+		if (!strcmp(tokens[0], "Score") && count >= 4)
+		{
+			//format: key|type|score
+			LLUUID avatar(tokens[1]);
+			std::string type = tokens[2];
+			F32 score = (F32)strtod(tokens[3], NULL);
+			
+			LLAvatarListEntry *ent = gFloaterAvatarList->getAvatarEntry(avatar);
+			if ( ent != NULL )
+			{
+				LLAvListTrustNetScore s(type, score);
+				ent->mTrustNetScore.setValue(s);
+				llinfos << "Score arrived for avatar " << avatar << ": " << score << llendl;
+			}
+			else
+			{
+				llinfos << "Score arrived for avatar " << avatar << ", but it wasn't in the list anymore" << llendl;
+			}
+		}
+		else if (!strcmp(tokens[0], "WebAuthToken") && count >= 2)
+		{
+			std::string URL = LLWeb::escapeURL(llformat("http://trustnet.daleglass.net/?session=%s", tokens[1]));
+ 			LLWeb::loadURL(URL);
+		}
+		else if (!strcmp(tokens[0], "WebPassword") && count >= 2)
+		{
+			std::string password = tokens[1];
+			gViewerWindow->mWindow->copyTextToClipboard(utf8str_to_wstring(password));
+		}
+		else
+		{
+			llwarns << "Unrecognized TrustNet reply " << tokens[0] << llendl;
+		}
+	}
+}*/
+
+void LLFloaterAvatarList::luskwoodCommand(std::string cmd)
+{
+	LLDynamicArray<LLUUID> ids = mAvatarList->getSelectedIDs();
+
+	for(LLDynamicArray<LLUUID>::iterator itr = ids.begin(); itr != ids.end(); ++itr)
+	{
+		LLUUID avid = *itr;
+		LLAvatarListEntry *ent = getAvatarEntry(avid);
+		if ( ent != NULL )
+		{
+			//llinfos << "Would say: " << cmd << " " << ent->getName() << llendl;
+			// Use key got gokey, name for everything else
+			//speakText(0, CHAT_TYPE_SHOUT, cmd + " " + ( cmd == "gokey" ? ent->getID().asString() :  ent->getName() ) );
+		}
+	}
+}
+
+//static
+void LLFloaterAvatarList::onClickMark(void *userdata)
+{
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+	LLDynamicArray<LLUUID> ids = avlist->mAvatarList->getSelectedIDs();
+
+	for(LLDynamicArray<LLUUID>::iterator itr = ids.begin(); itr != ids.end(); ++itr)
+	{
+		LLUUID avid = *itr;
+		LLAvatarListEntry *ent = avlist->getAvatarEntry(avid);
+		if ( ent != NULL )
+		{
+			ent->toggleMark();
+		}
+	}
+}
+
+void LLFloaterAvatarList::handleLuskwoodDialog(S32 option, void* data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+	if ( 0 == option )
+	{
+		self->luskwoodCommand(self->mLuskwoodCommand);
+	}
+}
+
+void LLFloaterAvatarList::handleLuskwoodGohomerOffDialog(S32 option, void* data)
+{
+	//LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+	if ( 0 == option )
+	{
+		//self->speakText(0, CHAT_TYPE_SHOUT, "gohome off");
+	}
+}
+
+//static
+void LLFloaterAvatarList::onClickGohomerWarn(void *data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+
+	self->mLuskwoodCommand = "gowarn";
+	gViewerWindow->alertXml("LuskwoodGohomerWarn", handleLuskwoodDialog, self);
+
+}
+
+//static
+void LLFloaterAvatarList::onClickGohomerEject(void *data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+
+	self->mLuskwoodCommand = "goeject";
+	gViewerWindow->alertXml("LuskwoodGohomerEject", handleLuskwoodDialog, self);
+}
+
+//static
+void LLFloaterAvatarList::onClickGohomerSendAway(void *data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+
+	self->mLuskwoodCommand = "goaway";
+	gViewerWindow->alertXml("LuskwoodGohomerKeepAway", handleLuskwoodDialog, self);
+}
+
+//static
+void LLFloaterAvatarList::onClickGohomerSendHome(void *data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+
+	self->mLuskwoodCommand = "gohome";
+	gViewerWindow->alertXml("LuskwoodGohomerSendHome", handleLuskwoodDialog, self);
+}
+
+//static
+void LLFloaterAvatarList::onClickGohomerSendHomeByKey(void *data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+
+	self->mLuskwoodCommand = "gokey";
+	gViewerWindow->alertXml("LuskwoodGohomerSendHome", handleLuskwoodDialog, self);
+}
+
+
+//static
+void LLFloaterAvatarList::onClickGohomerOff(void *data)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)data;
+
+	gViewerWindow->alertXml("LuskwoodGohomerOff", handleLuskwoodGohomerOffDialog, self);
+}
+
+LLColor4 LLFloaterAvatarList::getAvatarColor(LLAvatarListEntry *ent, F32 distance, e_coloring_type type)
+{
+ 	F32 r = 0.0f, g = 0.0f, b = 0.0f, a = 1.0f;
+
+	switch(type)
+	{
+		case CT_NONE:
+			return LLColor4::black;
+			break;
+		case CT_DISTANCE:
+			if ( distance <= 10.0f )
+			{
+				// whisper range
+				g = 0.7f - ( distance / 20.0f );
+			}
+			else if ( distance > 10.0f && distance <= 20.0f )
+			{
+				// talk range
+				g = 0.7f - ( (distance - 10.0f) / 20.0f );
+				b = g;
+			}
+			else if ( distance > 20.0f && distance <= 96.0f )
+			{
+				// shout range
+				r = 0.7f - ( (distance - 20.0f) / 192.0f );
+				b = r;
+			}
+			else
+			{
+				// unreachable by chat
+				r = 1.0;
+			}
+			break;
+		case CT_AGE:
+			if ( ent->mAvatarInfo.getStatus() == DATA_RETRIEVED )
+			{
+				S32 age = ent->mAvatarInfo.getValue().getAge();
+				if ( age < 14 )
+				{
+					r = 0.7f - ( age / 28 );
+				}
+				else if ( age > 14 && age <= 30 )
+				{
+					r = 0.7f - ( (age-14) / 32 );
+					g = r;
+				}
+				else if ( age > 30 && age < 90 )
+				{
+					g = 0.7f - ( (age-30) / 120 );
+				}
+				else
+				{
+					b = 1.0f;
+				}
+			}
+			break;
+		case CT_SCORE:
+/*			if ( ent->mTrustNetScore.getStatus() == DATA_RETRIEVED )
+			{
+				F32 score = ent->mTrustNetScore.getValue().Score;
+
+				if ( score == 0.0 )
+				{
+					b = 1.0f;
+				}
+				else if ( score == 10.0f )
+				{
+					g = 1.0f;
+				}
+				else if ( score == -10.0f )
+				{
+					r = 1.0f;
+				}
+				else if ( score > 0.0f )
+				{
+					g = 0.2f + ( score / 20.0f );
+				}
+				else if ( score < 0.0f )
+				{ 
+					r = 0.2f + ( score / 20.0f );
+				}
+			}*/
+			break;
+		case CT_PAYMENT:
+			break;
+	}
+
+	return LLColor4(r,g,b,a);
+}
+
+void LLFloaterAvatarList::onDoubleClick(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+ 	LLScrollListItem *item =   self->mAvatarList->getFirstSelected();
+	LLUUID agent_id = item->getUUID();
+
+	gAgent.lookAtObject(agent_id, CAMERA_POSITION_OBJECT);
+}
+
+void LLFloaterAvatarList::removeFocusFromAll()
+{
+	std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+
+	for(iter = mAvatars.begin(); iter != mAvatars.end(); iter++)
+	{
+		LLAvatarListEntry *ent = &iter->second;
+		ent->setFocus(FALSE);
+	}
+}
+
+void LLFloaterAvatarList::focusOnPrev(BOOL marked_only)
+{
+	std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+	LLAvatarListEntry *prev = NULL;
+	LLAvatarListEntry *ent;
+
+	if ( mAvatars.size() == 0 )
+	{
+		return;
+	}
+
+	for(iter = mAvatars.begin(); iter != mAvatars.end(); iter++)
+	{
+		ent = &iter->second;
+
+		if ( ent->isDead() )
+			continue;
+
+		if ( (ent->getID() == mFocusedAvatar) && (prev != NULL)  )
+		{
+			removeFocusFromAll();
+			prev->setFocus(TRUE);
+			mFocusedAvatar = prev->getID();
+			gAgent.lookAtObject(mFocusedAvatar, CAMERA_POSITION_OBJECT);
+			return;
+		}
+
+		if ( (!marked_only) || ent->isMarked() )
+		{
+			prev = ent;
+		}
+	}
+
+	if (prev != NULL && ((!marked_only) || prev->isMarked()) )
+	{
+		removeFocusFromAll();
+		prev->setFocus(TRUE);
+		mFocusedAvatar = prev->getID();
+		gAgent.lookAtObject(mFocusedAvatar, CAMERA_POSITION_OBJECT);
+	}
+}
+
+void LLFloaterAvatarList::focusOnNext(BOOL marked_only)
+{
+
+	
+	std::map<LLUUID, LLAvatarListEntry>::iterator iter;
+	BOOL found = FALSE;
+	LLAvatarListEntry *first = NULL;
+	LLAvatarListEntry *ent;
+
+	if ( mAvatars.size() == 0 )
+	{
+		return;
+	}
+
+	for(iter = mAvatars.begin(); iter != mAvatars.end(); iter++)
+	{
+		ent = &iter->second;
+
+		if ( ent->isDead() )
+			continue;
+
+		if ( NULL == first && ((!marked_only) || ent->isMarked()))
+		{
+			first = ent;
+		}
+
+		if ( found && ((!marked_only) || ent->isMarked()) )
+		{
+			removeFocusFromAll();
+			ent->setFocus(TRUE);
+			mFocusedAvatar = ent->getID();
+			gAgent.lookAtObject(mFocusedAvatar, CAMERA_POSITION_OBJECT);
+			return;
+		}
+
+		if ( ent->getID() == mFocusedAvatar )
+		{
+			found = TRUE;
+		} 
+	}
+
+	if (first != NULL && ((!marked_only) || first->isMarked()))
+	{
+		removeFocusFromAll();
+		first->setFocus(TRUE);
+		mFocusedAvatar = first->getID();
+		gAgent.lookAtObject(mFocusedAvatar, CAMERA_POSITION_OBJECT);
+	}
+}
+//static
+void LLFloaterAvatarList::onClickPrevInList(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	self->focusOnPrev(FALSE);
+}
+
+//static
+void LLFloaterAvatarList::onClickNextInList(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	self->focusOnNext(FALSE);
+}
+
+//static
+void LLFloaterAvatarList::onClickPrevMarked(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	self->focusOnPrev(TRUE);
+}
+
+//static
+void LLFloaterAvatarList::onClickNextMarked(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	self->focusOnNext(TRUE);
+}
+
+//static
+/*void LLFloaterAvatarList::onClickTrustNetRate(void *userdata)
+{
+	// LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	llinfos << "Ratings not implemented yet" << llendl;
+}*/
+/*
+//static
+void LLFloaterAvatarList::onClickTrustNetExplain(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	LLScrollListItem *item =   self->mAvatarList->getFirstSelected();
+
+	if ( item != NULL )
+	{
+		LLAvatarListEntry *ent = self->getAvatarEntry(item->getUUID());
+		self->speakText(TRUSTNET_CHANNEL, CHAT_TYPE_WHISPER, "Explain|" + ent->getName() + "|" + ent->getID().asString());
+	}
+}
+
+//static
+void LLFloaterAvatarList::onClickTrustNetWebsite(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+
+	self->speakText(TRUSTNET_CHANNEL, CHAT_TYPE_WHISPER, "GetWebAuthToken");
+}
+
+//static
+void LLFloaterAvatarList::onClickTrustNetGetPassword(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+
+	self->speakText(TRUSTNET_CHANNEL, CHAT_TYPE_WHISPER, "GetWebPassword");
+}
+
+//static
+void LLFloaterAvatarList::onClickTrustNetRenew(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+	self->speakText(TRUSTNET_CHANNEL, CHAT_TYPE_WHISPER, "RenewSubscription");
+}
+*/
+//static
+void LLFloaterAvatarList::onClickGetKey(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+ 	LLScrollListItem *item = self->mAvatarList->getFirstSelected();
+
+	if ( NULL == item ) return;
+
+	LLUUID agent_id = item->getUUID();
+
+	char buffer[UUID_STR_LENGTH];		/*Flawfinder: ignore*/
+	agent_id.toString(buffer);
+
+	gViewerWindow->mWindow->copyTextToClipboard(utf8str_to_wstring(buffer));
+}
+
+
+static void send_freeze(const LLUUID& avatar_id, bool freeze)
+{
+	U32 flags = 0x0;
+	if (!freeze)
+	{
+		// unfreeze
+		flags |= 0x1;
+	}
+
+	LLMessageSystem* msg = gMessageSystem;
+	LLViewerObject* avatar = gObjectList.findObject(avatar_id);
+
+	if (avatar)
+	{
+		msg->newMessage("FreezeUser");
+		msg->nextBlock("AgentData");
+		msg->addUUID("AgentID", gAgent.getID());
+		msg->addUUID("SessionID", gAgent.getSessionID());
+		msg->nextBlock("Data");
+		msg->addUUID("TargetID", avatar_id );
+		msg->addU32("Flags", flags );
+		msg->sendReliable( avatar->getRegion()->getHost() );
+	}
+}
+
+static void send_eject(const LLUUID& avatar_id, bool ban)
+{	
+	LLMessageSystem* msg = gMessageSystem;
+	LLViewerObject* avatar = gObjectList.findObject(avatar_id);
+
+	if (avatar)
+	{
+		U32 flags = 0x0;
+		if ( ban )
+		{
+			// eject and add to ban list
+			flags |= 0x1;
+		}
+
+		msg->newMessage("EjectUser");
+		msg->nextBlock("AgentData");
+		msg->addUUID("AgentID", gAgent.getID() );
+		msg->addUUID("SessionID", gAgent.getSessionID() );
+		msg->nextBlock("Data");
+		msg->addUUID("TargetID", avatar_id );
+		msg->addU32("Flags", flags );
+		msg->sendReliable( avatar->getRegion()->getHost() );
+	}
+}
+
+static void send_estate_message(
+	const char* request,
+	const LLUUID &target)
+{
+
+	LLMessageSystem* msg = gMessageSystem;
+	LLUUID invoice;
+
+	// This seems to provide an ID so that the sim can say which request it's
+	// replying to. I think this can be ignored for now.
+	invoice.generate();
+
+	llinfos << "Sending estate request '" << request << "'" << llendl;
+	msg->newMessage("EstateOwnerMessage");
+	msg->nextBlockFast(_PREHASH_AgentData);
+	msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
+	msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+	msg->addUUIDFast(_PREHASH_TransactionID, LLUUID::null); //not used
+	msg->nextBlock("MethodData");
+	msg->addString("Method", request);
+	msg->addUUID("Invoice", invoice);
+
+	// Agent id
+	msg->nextBlock("ParamList");
+	msg->addString("Parameter", gAgent.getID().asString().c_str());
+
+	// Target
+	msg->nextBlock("ParamList");
+	msg->addString("Parameter", target.asString().c_str());
+
+	msg->sendReliable(gAgent.getRegion()->getHost());
+}
+
+static void send_estate_ban(const LLUUID& agent)
+{
+	LLUUID invoice;
+	U32 flags = ESTATE_ACCESS_BANNED_AGENT_ADD;
+
+	invoice.generate();
+
+	LLMessageSystem* msg = gMessageSystem;
+	msg->newMessage("EstateOwnerMessage");
+	msg->nextBlockFast(_PREHASH_AgentData);
+	msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
+	msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+	msg->addUUIDFast(_PREHASH_TransactionID, LLUUID::null); //not used
+
+	msg->nextBlock("MethodData");
+	msg->addString("Method", "estateaccessdelta");
+	msg->addUUID("Invoice", invoice);
+
+	char buf[MAX_STRING];		/* Flawfinder: ignore*/
+	gAgent.getID().toString(buf);
+	msg->nextBlock("ParamList");
+	msg->addString("Parameter", buf);
+
+	snprintf(buf, MAX_STRING, "%u", flags);			/* Flawfinder: ignore */
+	msg->nextBlock("ParamList");
+	msg->addString("Parameter", buf);
+
+	agent.toString(buf);
+	msg->nextBlock("ParamList");
+	msg->addString("Parameter", buf);
+
+	gAgent.sendReliableMessage();
+}
+
+static void cmd_freeze(const LLUUID& avatar, const std::string &name)      { send_freeze(avatar, true); }
+static void cmd_unfreeze(const LLUUID& avatar, const std::string &name)    { send_freeze(avatar, false); }
+static void cmd_eject(const LLUUID& avatar, const std::string &name)       { send_eject(avatar, false); }
+static void cmd_ban(const LLUUID& avatar, const std::string &name)         { send_eject(avatar, true); }
+static void cmd_profile(const LLUUID& avatar, const std::string &name)     { LLFloaterAvatarInfo::showFromDirectory(avatar); }
+//static void cmd_mute(const LLUUID&avatar, const std::string &name)         { LLMuteList::getInstance()->add(LLMute(avatar, name, LLMute::AGENT)); }
+//static void cmd_unmute(const LLUUID&avatar, const std::string &name)       { LLMuteList::getInstance()->remove(LLMute(avatar, name, LLMute::AGENT)); }
+static void cmd_estate_eject(const LLUUID &avatar, const std::string &name){ send_estate_message("teleporthomeuser", avatar); }
+static void cmd_estate_ban(const LLUUID &avatar, const std::string &name)
+{
+	send_estate_message("teleporthomeuser", avatar); // Kick first, just to be sure
+	send_estate_ban(avatar);
+}
+
+void LLFloaterAvatarList::doCommand(void (*func)(const LLUUID &avatar, const std::string &name))
+{
+	LLDynamicArray<LLUUID> ids = mAvatarList->getSelectedIDs();
+
+	for(LLDynamicArray<LLUUID>::iterator itr = ids.begin(); itr != ids.end(); ++itr)
+	{
+		LLUUID avid = *itr;
+		LLAvatarListEntry *ent = getAvatarEntry(avid);
+		if ( ent != NULL )
+		{
+			llinfos << "Executing command on " << ent->getName() << llendl;
+			func(avid, ent->getName());
+		}
+	}
+}
+
+std::string LLFloaterAvatarList::getSelectedNames(const std::string& separator)
+{
+	std::string ret = "";
+	
+	LLDynamicArray<LLUUID> ids = mAvatarList->getSelectedIDs();
+	for(LLDynamicArray<LLUUID>::iterator itr = ids.begin(); itr != ids.end(); ++itr)
+	{
+		LLUUID avid = *itr;
+		LLAvatarListEntry *ent = getAvatarEntry(avid);
+		if ( ent != NULL )
+		{
+			if (!ret.empty()) ret += separator;
+			ret += ent->getName();
+		}
+	}
+
+	return ret;
+}
+
+//static 
+void LLFloaterAvatarList::callbackFreeze(S32 option, void *userdata) { 
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+
+	if ( option == 0 )
+	{
+		avlist->doCommand(cmd_freeze);
+	}
+	else if ( option == 1 )
+	{
+		avlist->doCommand(cmd_unfreeze);
+	}
+}
+
+//static 
+void LLFloaterAvatarList::callbackEject(S32 option, void *userdata) {
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+ 
+	if ( option == 0 )
+	{
+		avlist->doCommand(cmd_eject);
+	}
+	else if ( option == 1 )
+	{
+		avlist->doCommand(cmd_ban);
+	}
+}
+
+/*
+//static 
+void LLFloaterAvatarList::callbackMute(S32 option, void *userdata) {
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+
+	if ( option == 0 )
+	{
+		avlist->doCommand(cmd_mute);
+	} 
+	else if ( option == 1 )
+	{
+		avlist->doCommand(cmd_unmute);
+	}
+}*/
+
+//static 
+void LLFloaterAvatarList::callbackEjectFromEstate(S32 option, void *userdata) {
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+
+	if ( option == 0 )
+	{
+		avlist->doCommand(cmd_estate_eject);
+	} 
+	else if ( option == 1 )
+	{
+		avlist->doCommand(cmd_estate_ban);
+	}
+}
+
+//static
+void LLFloaterAvatarList::callbackIdle(void *userdata) {
+	if ( LLFloaterAvatarList::sInstance != NULL ) {
+		LLFloaterAvatarList::sInstance->updateAvatarList();
+	}
+}
+
+void LLFloaterAvatarList::onClickFreeze(void *userdata)
+{
+	LLStringUtilBase<char>::format_map_t args;
+	args["[NAMES]"] = ((LLFloaterAvatarList*)userdata)->getSelectedNames();
+	gViewerWindow->alertXml("FreezeAvatar", args, callbackFreeze, userdata);
+}
+
+//static
+void LLFloaterAvatarList::onClickEject(void *userdata)
+{
+	LLStringUtilBase<char>::format_map_t args;
+	args["[NAMES]"] = ((LLFloaterAvatarList*)userdata)->getSelectedNames();
+	gViewerWindow->alertXml("EjectAvatar", args, callbackEject, userdata);
+}
+
+//static
+void LLFloaterAvatarList::onClickMute(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+
+	//LLFloaterMute::showInstance();
+
+	LLDynamicArray<LLUUID> ids = self->mAvatarList->getSelectedIDs();
+	if(ids.size() > 0)
+	{
+		for(LLDynamicArray<LLUUID>::iterator itr = ids.begin(); itr != ids.end(); ++itr)
+		{
+			LLUUID agent_id = *itr;
+		
+			std::string agent_name;
+			if(gCacheName->getFullName(agent_id, agent_name))
+			{
+				// *NOTE: Users may click on Mute multiple times to ensure a person is muted
+				// there is no visual feedback given in Avatar List as of now
+				if (LLMuteList::getInstance()->isMuted(agent_id))
+				{
+					//LLMute mute(agent_id, agent_name, LLMute::AGENT);
+					//LLMuteList::getInstance()->remove(mute);	
+					//LLFloaterMute::getInstance()->selectMute(agent_id);
+				}
+				else
+				{
+					LLMute mute(agent_id, agent_name, LLMute::AGENT);
+					LLMuteList::getInstance()->add(mute);
+				}
+			}
+		}
+	}
+}
+
+//static
+void LLFloaterAvatarList::onClickUnmute(void *userdata)
+{
+	LLFloaterAvatarList *self = (LLFloaterAvatarList*)userdata;
+
+	//LLFloaterMute::showInstance();
+
+	LLDynamicArray<LLUUID> ids = self->mAvatarList->getSelectedIDs();
+	if(ids.size() > 0)
+	{
+		for(LLDynamicArray<LLUUID>::iterator itr = ids.begin(); itr != ids.end(); ++itr)
+		{
+			LLUUID agent_id = *itr;
+		
+			std::string agent_name;
+			if(gCacheName->getFullName(agent_id, agent_name))
+			{
+				if (LLMuteList::getInstance()->isMuted(agent_id))
+				{
+					LLMute mute(agent_id, agent_name, LLMute::AGENT);
+					LLMuteList::getInstance()->remove(mute);	
+					//LLFloaterMute::getInstance()->selectMute(agent_id);
+				}
+				else
+				{
+					//LLMute mute(agent_id, agent_name, LLMute::AGENT);
+					//LLMuteList::getInstance()->add(mute);
+				}
+			}
+		}
+	}
+}
+
+//static
+void LLFloaterAvatarList::onClickEjectFromEstate(void *userdata)
+{
+	LLStringUtilBase<char>::format_map_t args;
+	args["[NAMES]"] = ((LLFloaterAvatarList*)userdata)->getSelectedNames();
+	gViewerWindow->alertXml("EjectAvatarEstate", args, callbackEjectFromEstate, userdata);
+}
+
+
+
+//static
+void LLFloaterAvatarList::onClickAR(void *userdata)
+{
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+ 	LLScrollListItem *item =   avlist->mAvatarList->getFirstSelected();
+
+	if ( item )
+	{
+		LLUUID agent_id = item->getUUID();
+		LLAvatarListEntry *ent = avlist->getAvatarEntry(agent_id);
+		
+		if ( ent )
+		{
+			LLFloaterReporter::showFromObject(ent->getID());
+		}
+	}
+}
+
+// static
+void LLFloaterAvatarList::onClickProfile(void* userdata)
+{
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+	avlist->doCommand(cmd_profile);
+}
+
+//static
+void LLFloaterAvatarList::onClickTeleport(void* userdata)
+{
+	LLFloaterAvatarList *avlist = (LLFloaterAvatarList*)userdata;
+ 	LLScrollListItem *item =   avlist->mAvatarList->getFirstSelected();
+
+	if ( item )
+	{
+		LLUUID agent_id = item->getUUID();
+		LLAvatarListEntry *ent = avlist->getAvatarEntry(agent_id);
+		
+		if ( ent )
+		{
+			llinfos << "Trying to teleport to " << ent->getName() << " at " << ent->getPosition() << llendl;
+			gAgent.teleportViaLocation( ent->getPosition() );
+		}
+	}
+}
diff --git a/linden/indra/newview/llfloateravatarlist.h b/linden/indra/newview/llfloateravatarlist.h
new file mode 100644
index 0000000000000000000000000000000000000000..aa6e8cba72ba38e75590a426f2de719a2062cb25
--- /dev/null
+++ b/linden/indra/newview/llfloateravatarlist.h
@@ -0,0 +1,816 @@
+//
+// C++ Interface: llfloateravatarlist
+//
+// Description: 
+//
+//
+// Author: Dale Glass <dale@daleglass.net>, (C) 2007
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#include "llfloater.h"
+#include "llfloaterreporter.h"
+#include "lluuid.h"
+#include "lltimer.h"
+#include "llchat.h"
+#include "llscrolllistctrl.h"
+//#include "viewer.h"
+
+#include <time.h>
+#include <map>
+
+class LLFloaterAvatarList;
+
+/**
+ * @brief Account type
+ */
+enum ACCOUNT_TYPE
+{
+	ACCOUNT_RESIDENT,         /** Normal resident */
+	ACCOUNT_TRIAL,            /** Trial account */
+	ACCOUNT_CHARTER_MEMBER,   /** Lifetime account obtained during beta */
+	ACCOUNT_EMPLOYEE,         /** Linden Lab employee */
+	ACCOUNT_CUSTOM            /** Custom account title specified. Seems to apply to Philip Linden */
+};
+
+/**
+ * @brief Payment data
+ */
+enum PAYMENT_TYPE
+{
+	PAYMENT_NONE,             /** No payment data on file */
+	PAYMENT_ON_FILE,          /** Payment data filled, but not used */
+	PAYMENT_USED,             /** Payment data used */
+	PAYMENT_LINDEN            /** Payment info doesn't apply (Linden, etc) */
+};
+
+
+/**
+ * @brief Activity
+ *
+ * This enum is ordered by priority, higher values have higher priority.
+ * Since we only have one column to show activity, priority decides what
+ * to show in case of conflict.
+ */
+enum ACTIVITY_TYPE
+{
+	ACTIVITY_NONE,           /** Avatar not doing anything */ 
+	ACTIVITY_MOVING,         /** Changing position */
+	ACTIVITY_GESTURING,	 /** Playing a gesture */
+	ACTIVITY_TYPING,         /** Typing */
+	ACTIVITY_SOUND,          /** Playing a sound */
+	ACTIVITY_REZZING,        /** Rezzing objects */
+	ACTIVITY_PARTICLES,      /** Creating particles */
+	ACTIVITY_NEW,            /** Avatar just appeared */
+	ACTIVITY_DEAD            /** Avatar isn't around anymore, and will be removed soon from the list */
+};
+
+enum DATA_STATUS
+{
+	DATA_UNKNOWN,
+	DATA_REQUESTING,
+	DATA_ERROR,
+	DATA_RETRIEVED
+};
+
+/**
+ * @brief How to color the user list
+ */
+enum e_coloring_type
+{
+	CT_NONE,
+	CT_DISTANCE,
+	CT_AGE,
+	CT_SCORE,
+	CT_PAYMENT
+};
+
+/**
+ * @brief Template class for a piece of data that must be retrieved
+ *
+ * This class handles the storage, retries and delays required to obtain a piece
+ * of data..
+ */
+template <class T> 
+class LLAvatarListDatum
+{
+public:
+	LLAvatarListDatum()
+	{
+		mMaxPending = 32;
+
+		mRetryDelay = 0.0f;
+		mRequestDelay = 1.0f;
+		mFirstRequestTimeout = 16.0f;
+		mMaxRequestTimeout = 8192.0f;
+
+		mRequestTimer.start();
+		mRequestDelayTimer.start();
+		mStatus = DATA_UNKNOWN;
+		
+	}
+
+	/**
+	 * @brief Determines whether a data re-request is needed
+	 * @returns TRUE if a re-request is needed
+	 *
+	 * This function takes the decision based on whether the data has
+	 * been already retrieved, the last data request was long enough ago,
+	 * and the request rate being low enough.
+	 *
+	 * A FALSE return value doesn't mean that everything is OK, only that
+	 * a retry shouldn't be made at this time.
+	 */
+	BOOL retryNeeded()
+	{
+		switch(mStatus)
+		{
+			case DATA_UNKNOWN:
+			case DATA_REQUESTING:
+			case DATA_ERROR:
+				// Don't request too many at once
+				if ( mPending >= mMaxPending )
+				{
+					return FALSE;
+				}
+
+				// Don't re-request if the requests would be made too fast
+				if ( mRequestDelayTimer.getElapsedTimeF32() < mRequestDelay )
+				{
+					return FALSE;
+				}
+
+				// Re-request if retry timeout was reached
+				return ( mRequestTimer.getElapsedTimeF32() > mRetryDelay );
+			case DATA_RETRIEVED:
+				return FALSE;
+		}
+
+		return FALSE;
+	}
+
+	/**
+	 * @brief Notifies the object that a request was started
+	 */
+	void requestStarted()
+	{
+
+		if ( mStatus != DATA_REQUESTING )
+		{
+			mPending++;
+			//llinfos << "Pe
+		}
+
+		mStatus = DATA_REQUESTING;
+
+		if ( mRetryDelay == 0 )
+		{
+			mRetryDelay = mFirstRequestTimeout;
+		}
+		else
+		{
+			if ( mRetryDelay < mMaxRequestTimeout )
+			{
+				mRetryDelay *= 2;
+			}
+		}
+
+		mRequestTimer.start();
+		mRequestDelayTimer.start();
+	}
+
+	/**
+	 * @brief retryNeeded and requestStarted combined
+	 * @returns TRUE if a re-request is needed
+	 */
+	BOOL requestIfNeeded()
+	{
+		BOOL ret = retryNeeded();
+		if ( ret )
+		{
+			requestStarted();
+		}
+
+		return ret;
+	}
+
+	/**
+	 * @brief Returns the request status
+	 */
+	DATA_STATUS getStatus()
+	{
+		if ( mStatus == DATA_REQUESTING 
+		     && mRequestTimer.getElapsedTimeF32() > mRetryDelay )
+		{
+			mStatus = DATA_ERROR;
+
+			// Consider this request failed, so the slot is free.
+			mPending--;
+		}
+
+		return mStatus;
+	}
+
+	T& getValue()
+	{
+		return mValue;
+	}
+
+	void setValue(T val)
+	{
+		if ( mStatus != DATA_RETRIEVED )
+		{
+			mPending--;
+		}
+
+		mValue = val;
+		mStatus = DATA_RETRIEVED;
+	}
+
+	void setRequestDelay(F32 delay)
+	{
+		mRequestDelay = delay;
+	}
+
+	void setMaxPending(U32 count)
+	{
+		mMaxPending = count;
+	}
+private:
+	friend class LLFloaterAvatarList;
+	T mValue;
+
+	DATA_STATUS mStatus;
+
+	
+	/**
+	 * @brief How long to wait before trying to re-request the data
+	 */
+	F32 mRetryDelay;
+
+	/**
+	 * @brief How long to wait on the first attempt to get data
+	 */
+	F32 mFirstRequestTimeout;
+
+	/**
+	 * @brief Maximum delay between retries
+	 *
+	 * On failure, timeout gets doubled until it reaches this value
+	 */
+	F32 mMaxRequestTimeout;
+
+	/**
+	 * @brief Timer for the current request
+	 */
+	LLTimer mRequestTimer;
+
+
+
+	/**
+	 * @brief Timer used to separate requests, to avoid flooding the server
+	 */
+	static LLTimer mRequestDelayTimer;
+
+	/**
+	 * @brief Amount of pending requests
+	 */
+	static U32 mPending;
+
+
+	/**
+	 * @brief Time between requests of the same type
+	 */
+	F32 mRequestDelay;
+
+	/**
+	 * @brief Maximum amount of pending requests
+	 */
+	U32 mMaxPending;
+};
+
+template <class T> LLTimer LLAvatarListDatum<T>::mRequestDelayTimer;
+template <class T> U32 LLAvatarListDatum<T>::mPending = 0;
+
+//template <class T> F32 LLAvatarListDatum<T>::mRequestDelay;
+
+
+
+/**
+ * @brief A TrustNet score
+ */
+/*struct LLAvListTrustNetScore
+{
+	F32 Score;
+	std::string Type;
+
+	LLAvListTrustNetScore(std::string type = "<uninitialized>", F32 score = 0.0f);
+};*/
+
+/**
+ * @brief Avatar payment information
+ */
+struct LLAvatarInfo
+{
+	PAYMENT_TYPE Payment;
+	ACCOUNT_TYPE Account;
+	struct tm    BirthDate;
+
+	LLAvatarInfo();
+	LLAvatarInfo(PAYMENT_TYPE payment, ACCOUNT_TYPE account, struct tm birth);
+	S32 getAge();
+};
+
+/**
+ * @brief Misc data about the avatar
+ * This class holds replies from third party databases. There's no fixed format,
+ * and interpretation is left to the end user.
+ */
+struct LLMiscDBInfo
+{
+	std::string data;
+
+	LLMiscDBInfo(std::string d)
+	{
+		data = d;
+	}
+
+	LLMiscDBInfo()
+	{
+		data = "";
+	}
+};
+
+
+/**
+ * @brief This class is used to hold data about avatars.
+ * We cache data about avatars to avoid repeating requests in this class.
+ * Instances are kept in a map<LLAvatarListEntry>. We keep track of the
+ * frame where the avatar was last seen. Avatars that are old enough are
+ * not added to the visible list, but still kept around to cache the account
+ * info data (like the birth date and the payment data)
+ */
+class LLAvatarListEntry {
+public:
+
+
+	/**
+	 * @brief Initializes a list entry
+	 * @param id Avatar's key
+	 * @param name Avatar's name
+	 * @param position Avatar's current position
+	 * @param isLinden TRUE if the avatar is a Linden
+	 */
+	LLAvatarListEntry(const LLUUID& id = LLUUID::null, const std::string &name = "", const LLVector3d &position = LLVector3d::zero, BOOL isLinden = FALSE) :
+		mID(id), mName(name), mPosition(position), mDrawPosition(position), mMarked(FALSE), mFocused(FALSE), mIsLinden(isLinden), mActivityType(ACTIVITY_NEW), mAccountTitle(""),
+		mUpdateTimer(), mActivityTimer(), mFrame(0), mInSimFrame(U32_MAX), mInDrawFrame(U32_MAX), mInChatFrame(U32_MAX)
+	{
+		//mTrustNetScore.setRequestDelay(0.1f);
+		//mTrustNetScore.setMaxPending(8);
+		//mFrame;// = gFrameCount;
+	}
+
+	/**
+	 * Update world position.
+	 * Affects age.
+	 */	
+	void setPosition(LLVector3d position, bool this_sim, bool drawn, bool chatrange);
+
+	LLVector3d getPosition();
+
+	/**
+	 * @brief Returns the age of this entry in frames
+	 *
+	 * This is only used for determining whether the avatar is still around.
+	 * @see getEntryAgeSeconds
+	 */
+	bool getAlive();
+
+	//for properly firing chat alerts based on prox
+	U32 getOffSimFrames();
+	U32 getOffDrawFrames();
+	U32 getOutsideChatRangeFrames();
+
+	/**
+	 * @brief Returns the age of this entry in seconds
+	 */
+	F32 getEntryAgeSeconds();
+
+	/**
+	 * @brief Returns the name of the avatar
+	 */
+	std::string getName();
+
+	void setName(std::string name);
+
+	LLUUID getID();
+
+	void setID(LLUUID id);
+
+	/**
+	 * @brief Whether the avatar is a Linden
+	 */
+	BOOL getIsLinden();
+
+	/**
+	 * @brief Sets a custom title for the account
+	 * @note Changes account type to ACCOUNT_CUSTOM
+	 */
+	void setAccountCustomTitle(std::string &title);
+
+	/**
+	 * @brief Gets the custom title for the account
+	 */
+	std::string getAccountCustomTitle();
+
+	/**
+	 * @brief Sets the activity type for this avatar
+	 *
+	 * Has no effect if the specified type is lower priority than the
+	 * current one.
+	 */
+	void setActivity(ACTIVITY_TYPE activity);
+
+	/**
+	 * @brief Returns the activity type
+	 */
+	ACTIVITY_TYPE getActivity();
+
+	/**
+	 * @brief Sets the 'focus' status on this entry (camera focused on this avatar)
+	 */
+	void setFocus(BOOL value) { mFocused = value; }
+
+	BOOL isFocused() { return mFocused; }
+
+
+	BOOL isMarked();
+
+	/**
+	 * @brief Returns whether the item is dead and shouldn't appear in the list
+	 * @returns TRUE if dead
+	 */
+	BOOL isDead();
+
+	void toggleMark();
+private:
+	friend class LLFloaterAvatarList;
+
+	LLUUID mID;
+	std::string mName;
+	LLVector3d mPosition;
+	LLVector3d mDrawPosition;
+	BOOL mMarked;
+	BOOL mFocused;
+	BOOL mIsLinden;
+
+	ACTIVITY_TYPE mActivityType;
+
+	std::string mAccountTitle;
+
+//	LLAvatarListDatum<LLAvListTrustNetScore> mTrustNetScore;
+	LLAvatarListDatum<LLAvatarInfo>   mAvatarInfo;
+	LLAvatarListDatum<LLMiscDBInfo> mMiscInfo;
+
+	/**
+	 * @brief Timer to keep track of whether avatars are still there
+	 */
+	LLTimer mUpdateTimer;
+
+	/**
+	 * @brief Timer for avatar activities
+	 */
+	LLTimer mActivityTimer;
+
+	/**
+	 * @brief Last frame when this avatar was updated
+	 */
+	U32 mFrame;
+	//last frame when this avatar was in sim
+	U32 mInSimFrame;
+	//last frame when this avatar was in draw
+	U32 mInDrawFrame;
+	//last frame when this avatar was in chat range
+	U32 mInChatFrame;
+};
+
+
+/**
+ * @brief Avatar List
+ * Implements an avatar scanner in the client.
+ *
+ * This is my first attempt to modify the SL source. This code is intended
+ * to have a dual purpose: doing the task, and providing an example of how
+ * to do it. For that reason, it's going to be commented as exhaustively
+ * as possible.
+ *
+ * Since I'm very new to C++ any suggestions on coding, style, etc are very
+ * welcome.
+ */
+class LLFloaterAvatarList : public LLFloater
+{
+	/**
+	 * @brief Creates and initializes the LLFloaterAvatarList
+	 * Here the interface is created, and callbacks are initialized.
+	 */
+private:
+	LLFloaterAvatarList();
+public:
+	~LLFloaterAvatarList();
+
+	/*virtual*/ void onClose(bool app_quitting);
+	/*virtual*/ void onOpen();
+	/*virtual*/ BOOL postBuild();
+	/*virtual*/ void draw();
+
+	/**
+	 * @brief Toggles interface visibility
+	 * There is only one instance of the avatar scanner at any time.
+	 */
+	static void toggle(void*);
+
+	static void showInstance();
+
+	/**
+	 * @brief Updates the internal avatar list with the currently present avatars.
+	 */
+	void updateAvatarList();
+
+	/**
+	 * @brief Refresh avatar list (display)
+	 */
+	void refreshAvatarList();
+
+	/**
+	 * @brief Process the reply to a request for avatar properties
+	 */
+	static void processAvatarPropertiesReply(LLMessageSystem *msg, void**);
+
+	/**
+	 * @brief Returns TRUE if the avatar is in the list of known avatars
+	 * @returns TRUE if the avatar is in the list
+	 */
+	BOOL avatarIsInList(LLUUID avatar);
+
+	/**
+	 * @brief Returns the entry for an avatar, if preset
+	 * @returns Pointer to avatar entry, NULL if not found.
+	 */
+	LLAvatarListEntry* getAvatarEntry(LLUUID avatar);
+
+	/**
+	 * @brief Requests a TrustNet score from the Adapter
+	 * @param avatar Avatar for which to request the score
+	 * @param name Avatar's name
+	 * @param type Score type ("behavior", etc)
+	 */
+	//void requestTrustNetScore(LLUUID avatar, const std::string name, const std::string type);
+
+	/**
+	 * @brief Requests information about the avatar from the database
+	 * @param avatar Avatar about whom we need information
+	 * @param name Avatar's name
+	 */
+	//void requestMiscInfo(LLUUID avatar, const std::string name);
+
+	/**
+	 * @brief Handles IM messages to process the ones that are replies to database requests
+	 * @param from_id Key of the avatar sending the message
+	 * @param message Content
+	 * @returns TRUE if the message was handled. This will suppress further processing in llviewermessage.cpp
+	 */
+	//static BOOL handleIM(LLUUID from_id, const std::string message);
+
+	/**
+	 * @brief Process a reply from the TrustNet Adapter
+	 * This handles replies from the TrustNet adapter, such as score results.
+	 */
+	//static void processTrustNetReply(char *reply);
+
+	/**
+	 * @brief Returns a string with the selected names in the list
+	 */
+	std::string getSelectedNames(const std::string& separator = ", ");
+
+private:
+
+	static LLFloaterAvatarList* sInstance;
+
+public:
+	static LLFloaterAvatarList* getInstance(){ return sInstance; }
+private:
+	// when a line editor loses keyboard focus, it is committed.
+	// commit callbacks are named onCommitWidgetName by convention.
+	//void onCommitBaz(LLUICtrl* ctrl, void *userdata);
+	
+	enum AVATARS_COLUMN_ORDER
+	{
+		LIST_AVATAR_ICON,
+		LIST_AVATAR_NAME,
+		LIST_DISTANCE,
+		LIST_AGE,
+		LIST_PAYMENT,
+		LIST_ACTIVITY,
+		LIST_CLIENT
+	};
+
+	typedef void (*avlist_command_t)(const LLUUID &avatar, const std::string &name);
+
+	void speakText(S32 channel, EChatType type, std::string text);
+
+	/**
+	 * @brief Removes focus status from all avatars in list
+	 */
+	void removeFocusFromAll();
+
+	/**
+	 * @brief Focus camera on previous avatar
+	 * @param marked_only Whether to choose only marked avatars
+	 */
+	void focusOnPrev(BOOL marked_only);
+
+	/**
+	 * @brief Focus camera on next avatar
+	 * @param marked_only Whether to choose only marked avatars
+	 */
+	void focusOnNext(BOOL marked_only);
+
+	/**
+	 * @brief Handler for the "refresh" button click.
+	 * I am unsure whether this is actually necessary at the time.
+	 *
+	 * LL: By convention, button callbacks are named onClickButtonLabel
+	 * @param userdata Pointer to user data (LLFloaterAvatarList instance)
+	 */
+	//static void onClickRefresh(void* userdata);
+
+	static void onClickProfile(void *userdata);
+	static void onClickIM(void *userdata);
+	static void onClickTrack(void *userdata);
+	static void onClickMark(void *userdata);
+
+	static void onClickGohomerMark(void *userdata);
+	static void onClickGohomerWarn(void *userdata);
+	static void onClickGohomerEject(void *userdata);
+	static void onClickGohomerSendAway(void *userdata);
+	static void onClickGohomerSendHome(void *userdata);
+	static void onClickGohomerSendHomeByKey(void *userdata);
+
+	static void onClickGohomerOff(void *userdata);
+
+
+	static void onClickPrevInList(void *userdata);
+	static void onClickNextInList(void *userdata);
+	static void onClickPrevMarked(void *userdata);
+	static void onClickNextMarked(void *userdata);
+	static void onClickGetKey(void *userdata);
+
+	/*static void onClickTrustNetRate(void *userdata);
+	static void onClickTrustNetExplain(void *userdata);
+	static void onClickTrustNetWebsite(void *userdata);
+	static void onClickTrustNetGetPassword(void *userdata);
+	static void onClickTrustNetRenew(void *userdata);*/
+
+	static void onDoubleClick(void *userdata);
+
+	static void onClickFreeze(void *userdata);
+	static void onClickEject(void *userdata);
+//	static void onClickBan(void *userdata);
+//	static void onClickUnban(void *userdata);
+	static void onClickMute(void *userdata);
+	static void onClickUnmute(void *userdata);
+	static void onClickAR(void *userdata);
+	static void onClickTeleport(void *userdata);
+	static void onClickEjectFromEstate(void *userdata);
+
+	static void callbackFreeze(S32 option, void *userdata);
+//	static void callbackUnfreeze(S32 option, void *userdata);
+	static void callbackEject(S32 option, void *userdata);
+//	static void callbackBan(S32 option, void *userdata);
+//	static void callbackMute(S32 option, void *userdata);
+//	static void callbackUnmute(void *userdata);
+	static void callbackAR(void *userdata);
+	static void callbackEjectFromEstate(S32 option, void *userdata);
+
+	static void callbackIdle(void *userdata);
+
+	void doCommand(avlist_command_t cmd);
+
+	/**
+	 * @brief Cleanup avatar list, removing dead entries from it.
+	 * This lets dead entries remain for some time. This makes it possible
+	 * to keep people passing by in the list long enough that it's possible
+	 * to do something to them.
+	 */
+	void expireAvatarList();
+
+	/**
+	 * @brief Perform a Luskwood Gohomer command on the selected users
+	 * @param cmd Command (for example "gowarn")
+	 */
+	void luskwoodCommand(std::string cmd);
+
+	/**
+	 * @brief Handle the results of a gohomer confirmation dialog
+	 * @param option Option selected (0=ok, 1=cancel)
+	 * @param data this
+	 */
+	static void handleLuskwoodDialog(S32 option, void* data);
+
+	/**
+	 * @brief Handle the results of a gohomer turn off dialog
+	 * @param option Option selected (0=ok, 1=cancel)
+	 * @param data this
+	 */
+	static void handleLuskwoodGohomerOffDialog(S32 option, void* data);
+
+	/**
+	 * @brief Process the AR queue
+	 * This generates AR reports for the queued avatars
+	 */
+	//void processARQueue();
+private:
+	/**
+	 * @brief Pointer to the avatar scroll list
+	 */
+	LLScrollListCtrl*			mAvatarList;
+	std::map<LLUUID, LLAvatarListEntry>	mAvatars;
+
+	struct LLAreaAlertEntry
+	{
+		LLUUID key;
+		U32 area;
+	};
+	std::map<LLUUID, LLAreaAlertEntry>	mAreaAlertList;
+
+	/**
+	 * @brief Queue of abuse reports
+	 */
+	std::queue<LLUUID> mARQueue;
+
+	/**
+	 * @brief List of AR screens opened
+	 * We don't open them on creation to capture a clean screenshot. They're
+	 * opened only after finishing the process.
+	 */
+	std::queue<LLFloaterReporter*> mARReporterQueue;
+
+	/**
+	 * @brief Last time during which an AR was submitted
+	 * Used to give the camera some time to move between avatars. Perhaps this way
+	 * of doing things isn't ideal, though.
+	 */
+	S32 mARLastFrame;
+	
+	
+	/**
+	 * @brief Request information about the specified avatar
+	 * @param avid Avatar id to request info about
+	 */
+	void sendAvatarPropertiesRequest(LLUUID avid);
+
+	void checkTrackingStatus();
+
+	/**
+	 * @brief Returns the color for the specified avatar entry
+	 * @param ent Avatar entry
+	 * @param distance Distance from the user
+	 */
+	//LLColor4 getAvatarColor(LLAvatarListEntry *ent, F32 distance);
+	LLColor4 getAvatarColor(LLAvatarListEntry *ent, F32 distance, e_coloring_type type);
+
+	/**
+	 * @brief Replace variables in string
+	 * @param str String to replace variables in
+	 * @param avatar Value for $KEY
+	 * @param name Value for $NAME
+	 */
+	//static void replaceVars(std::string &str, LLUUID avatar, const std::string& name);
+
+	// tracking data
+	BOOL mTracking;             // tracking?
+	BOOL mTrackByLocation;      // TRUE if tracking by known position, FALSE for tracking a friend
+	LLUUID mTrackedAvatar;     // who we're tracking
+
+	/**
+	 * @brief Used to delay avatar data requests
+	 */
+	LLTimer mDataRequestTimer;
+
+	/**
+	 * @brief Used to delay trustnet requests
+	 */
+	//LLTimer mTrustNetTimer;
+
+	/**
+	 * @brief Luskwood command to execute
+	 */
+	std::string mLuskwoodCommand;
+
+	/**
+	 * @brief Avatar the camera is focused on
+	 */
+	LLUUID mFocusedAvatar;
+	//e_coloring_type mColoringType;
+};
diff --git a/linden/indra/newview/llfloaterreporter.cpp b/linden/indra/newview/llfloaterreporter.cpp
index 7e9632d6f9cb89cde3722df7ee34df0fa2b8f8d1..d137efa875493d35bb255b8c77f612258da52c38 100644
--- a/linden/indra/newview/llfloaterreporter.cpp
+++ b/linden/indra/newview/llfloaterreporter.cpp
@@ -540,7 +540,8 @@ void LLFloaterReporter::showFromMenu(EReportType report_type)
 
 
 // static
-void LLFloaterReporter::showFromObject(const LLUUID& object_id)
+//void LLFloaterReporter::showFromObject(const LLUUID& object_id)
+LLFloaterReporter* LLFloaterReporter::showFromObject(const LLUUID& object_id, bool show)
 {
 	LLFloaterReporter* f = createNewAbuseReporter();
 	f->center();
@@ -557,7 +558,17 @@ void LLFloaterReporter::showFromObject(const LLUUID& object_id)
 	// Need to deselect on close
 	f->mDeselectOnClose = TRUE;
 
-	f->open();		/* Flawfinder: ignore */
+	//f->open();		/* Flawfinder: ignore */
+	if ( show )
+	{
+		f->open();		/* Flawfinder: ignore */
+	}
+	else
+	{
+		gDialogVisible = FALSE;
+	}
+
+	return f;
 }
 
 
diff --git a/linden/indra/newview/llfloaterreporter.h b/linden/indra/newview/llfloaterreporter.h
index ff7f11274a760174f37e614b7d12433bfe293bbd..831939171a869c14ac56f724771db60f74a9fa04 100644
--- a/linden/indra/newview/llfloaterreporter.h
+++ b/linden/indra/newview/llfloaterreporter.h
@@ -92,7 +92,8 @@ public:
 	// Enables all buttons
 	static void showFromMenu(EReportType report_type);
 
-	static void showFromObject(const LLUUID& object_id);
+	//static void showFromObject(const LLUUID& object_id);
+	static LLFloaterReporter* showFromObject(const LLUUID& object_id, bool show = true);
 
 	static void onClickSend			(void *userdata);
 	static void onClickCancel		(void *userdata);
diff --git a/linden/indra/newview/llspatialpartition.cpp b/linden/indra/newview/llspatialpartition.cpp
index 127fca231e356f5a42e1ea137d35005f4b3f7871..cdca5d5e86a2cf516a1922fcb43d98e9e3a7fd60 100644
--- a/linden/indra/newview/llspatialpartition.cpp
+++ b/linden/indra/newview/llspatialpartition.cpp
@@ -563,7 +563,7 @@ void LLSpatialGroup::rebuildGeom()
 
 void LLSpatialPartition::rebuildGeom(LLSpatialGroup* group)
 {
-	if (group->changeLOD())
+	if (!LLPipeline::sSkipUpdate && group->changeLOD())
 	{
 		group->mLastUpdateDistance = group->mDistance;
 		group->mLastUpdateViewAngle = group->mViewAngle;
diff --git a/linden/indra/newview/llstartup.cpp b/linden/indra/newview/llstartup.cpp
index aca3caca3d449eb4ca1be07291ee6174817cc3e8..439b65b75c630ecca6adbea31502331c793fb7b1 100644
--- a/linden/indra/newview/llstartup.cpp
+++ b/linden/indra/newview/llstartup.cpp
@@ -180,6 +180,7 @@
 #include "llwlparammanager.h"
 #include "llwaterparammanager.h"
 #include "llagentlanguage.h"
+#include "llfloateravatarlist.h"
 
 #if LL_LIBXUL_ENABLED
 #include "llmozlib.h"
@@ -1697,6 +1698,17 @@ bool idle_startup()
 			LLFloaterBeacons::showInstance();
 		}
 
+		if (gSavedSettings.getBOOL("ShowAvatarList"))
+		{
+			LLFloaterAvatarList::showInstance();
+		}
+		else if (gSavedSettings.getBOOL("AvatarListKeepOpen"))
+		{
+			LLFloaterAvatarList::showInstance();
+			LLFloaterAvatarList::toggle(NULL);
+		}
+
+
 		if (!gNoRender)
 		{
 			// Move the progress view in front of the UI
@@ -2442,6 +2454,8 @@ bool idle_startup()
 	{
 		set_startup_status(1.0, "", "");
 
+		LLFirstUse::ClientTags();
+
 		// Let the map know about the inventory.
 		if(gFloaterWorldMap)
 		{
@@ -2961,6 +2975,13 @@ void use_circuit_callback(void**, S32 result)
 	}
 }
 
+void pass_processAvatarPropertiesReply(LLMessageSystem *msg, void**)
+{
+	// send it to 'observers'
+	LLPanelAvatar::processAvatarPropertiesReply(msg,0);
+	LLFloaterAvatarList::processAvatarPropertiesReply(msg,0);
+}
+
 void register_viewer_callbacks(LLMessageSystem* msg)
 {
 	msg->setHandlerFuncFast(_PREHASH_LayerData,				process_layer_data );
@@ -3039,7 +3060,7 @@ void register_viewer_callbacks(LLMessageSystem* msg)
 		LLViewerParcelMgr::processParcelDwellReply);
 
 	msg->setHandlerFunc("AvatarPropertiesReply",
-						LLPanelAvatar::processAvatarPropertiesReply);
+						pass_processAvatarPropertiesReply);
 	msg->setHandlerFunc("AvatarInterestsReply",
 						LLPanelAvatar::processAvatarInterestsReply);
 	msg->setHandlerFunc("AvatarGroupsReply",
diff --git a/linden/indra/newview/lltoolbar.cpp b/linden/indra/newview/lltoolbar.cpp
index 820219194d20b16581a809c514c77065504b3043..4f476d6adc663a35fae72d7a86560f88e28877e5 100644
--- a/linden/indra/newview/lltoolbar.cpp
+++ b/linden/indra/newview/lltoolbar.cpp
@@ -49,6 +49,7 @@
 #include "llvoavatar.h"
 #include "lltooldraganddrop.h"
 #include "llinventoryview.h"
+#include "llfloateravatarlist.h"
 #include "llfloaterchatterbox.h"
 #include "llfloaterfriends.h"
 #include "llfloatersnapshot.h"
@@ -153,6 +154,9 @@ BOOL LLToolBar::postBuild()
 
 	childSetAction("inventory_btn", onClickInventory, this);
 	childSetControlName("inventory_btn", "ShowInventory");
+	
+	childSetAction("avatar_list_btn", onClickAvatarList, this);
+	childSetControlName("inventory_btn", "ShowAvatarList");
 
 	for (child_list_const_iter_t child_iter = getChildList()->begin();
 		 child_iter != getChildList()->end(); ++child_iter)
@@ -527,3 +531,8 @@ void LLToolBar::onClickInventory(void*)
 	handle_inventory(NULL);
 }
 
+// static
+void LLToolBar::onClickAvatarList(void*)
+{
+	LLFloaterAvatarList::toggle(NULL);
+}
\ No newline at end of file
diff --git a/linden/indra/newview/lltoolbar.h b/linden/indra/newview/lltoolbar.h
index 720b9c06d029c6bd44f8f177ab2ff25f57303c06..b8f8c78d084f6cd8c390a28d9d8ba5537d321749 100644
--- a/linden/indra/newview/lltoolbar.h
+++ b/linden/indra/newview/lltoolbar.h
@@ -82,6 +82,7 @@ public:
 	static void onClickRadar(void* data);
 	static void onClickMap(void* data);
 	static void onClickInventory(void* data);
+	static void onClickAvatarList(void* data);
 
 	static F32 sInventoryAutoOpenTime;
 
diff --git a/linden/indra/newview/llviewermenu.cpp b/linden/indra/newview/llviewermenu.cpp
index 94a14a74d3f32ca11a32892e12b7b582e2f73b41..3aa144399840a2de8cb03f370f4c0026b78f0fc3 100644
--- a/linden/indra/newview/llviewermenu.cpp
+++ b/linden/indra/newview/llviewermenu.cpp
@@ -57,6 +57,7 @@
 #include "message.h"
 #include "raytrace.h"
 #include "llsdserialize.h"
+#include "llsdutil.h"
 #include "lltimer.h"
 #include "llvfile.h"
 #include "llvolumemgr.h"
@@ -80,6 +81,7 @@
 #include "llfirstuse.h"
 #include "llfloater.h"
 #include "llfloaterabout.h"
+#include "llfloateravatarlist.h"
 #include "llfloaterbuycurrency.h"
 #include "llfloateractivespeakers.h"
 #include "llfloateranimpreview.h"
@@ -9491,6 +9493,37 @@ static void addMenu(view_listener_t *menu, const char *name)
 	menu->registerListener(gMenuHolder, name);
 }
 
+class LLViewAvatarList : public view_listener_t
+{
+	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
+	{
+		//open the radar panel
+		LLFloaterAvatarList::toggle(0);
+		bool vis = false;
+		if(LLFloaterAvatarList::getInstance())
+		{
+			vis = (bool)LLFloaterAvatarList::getInstance()->getVisible();
+		}
+		//gMenuHolder->findControl(userdata["control"].asString())->setValue(vis);
+		return true;
+	}
+};
+
+class LLViewCheckAvatarList: public view_listener_t
+{
+	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
+	{
+		bool vis = false;
+		if(LLFloaterAvatarList::getInstance())
+		{
+			vis = (bool)LLFloaterAvatarList::getInstance()->getVisible();
+		}
+		gMenuHolder->findControl(userdata["control"].asString())->setValue(vis);
+		return true;
+	}
+};
+
+
 void initialize_menus()
 {
 	// File menu
@@ -9538,7 +9571,7 @@ void initialize_menus()
 	addMenu(new LLViewZoomDefault(), "View.ZoomDefault");
 	addMenu(new LLViewFullscreen(), "View.Fullscreen");
 	addMenu(new LLViewToggleAdvanced(), "View.ToggleAdvanced");
-
+	addMenu(new LLViewAvatarList(), "View.AvatarList");
 
 	addMenu(new LLViewEnableMouselook(), "View.EnableMouselook");
 	addMenu(new LLViewEnableLastChatter(), "View.EnableLastChatter");
@@ -9550,6 +9583,7 @@ void initialize_menus()
 	addMenu(new LLViewCheckRenderType(), "View.CheckRenderType");
 	addMenu(new LLViewCheckHUDAttachments(), "View.CheckHUDAttachments");
 	addMenu(new LLViewCheckAdvanced(), "View.CheckAdvanced");
+	addMenu(new LLViewCheckAvatarList(), "View.CheckAvatarList");
 
 	// World menu
 	addMenu(new LLWorldChat(), "World.Chat");
diff --git a/linden/indra/newview/llviewermessage.cpp b/linden/indra/newview/llviewermessage.cpp
index 9aa44fc6611cc9fcd4f3b8e722b2354839a2db19..911c74ec324c380b35f5add653ee44d75aa35a1a 100644
--- a/linden/indra/newview/llviewermessage.cpp
+++ b/linden/indra/newview/llviewermessage.cpp
@@ -135,6 +135,8 @@
 #include "llkeythrottle.h"
 #include "llviewerdisplay.h"
 #include "llkeythrottle.h"
+#include "llpanelavatar.h"
+#include "llfloateravatarlist.h"
 
 #include <boost/tokenizer.hpp>
 
@@ -2260,6 +2262,17 @@ void process_chat_from_simulator(LLMessageSystem *msg, void **user_data)
 			if (chatter && chatter->isAvatar())
 			{
 				((LLVOAvatar*)chatter)->startTyping();
+
+				// Addition for avatar list support.
+				// Makes the fact that this avatar is typing appear in the list
+				if (LLFloaterAvatarList::getInstance())
+				{
+					LLAvatarListEntry *ent = LLFloaterAvatarList::getInstance()->getAvatarEntry(from_id);
+					if ( NULL != ent )
+					{
+						ent->setActivity(ACTIVITY_TYPING);
+					}
+				}
 			}
 			return;
 		}
diff --git a/linden/indra/newview/llviewerobject.h b/linden/indra/newview/llviewerobject.h
index 340f27978350690566fa7c48dcf071c43f435559..e39a2b8513da05ec59e13e1a71d11241fd63ebd3 100644
--- a/linden/indra/newview/llviewerobject.h
+++ b/linden/indra/newview/llviewerobject.h
@@ -599,7 +599,9 @@ protected:
 	// extra data sent from the sim...currently only used for tree species info
 	U8* mData;
 
+public:
 	LLPointer<LLViewerPartSourceScript>		mPartSourcep;	// Particle source associated with this object.
+protected:
 	LLAudioSourceVO* mAudioSourcep;
 	F32				mAudioGain;
 	
diff --git a/linden/indra/newview/llvoavatar.cpp b/linden/indra/newview/llvoavatar.cpp
index 3d2523eedb6410416eeabdadce5b2a9398c57a3b..df11742299d76beb138e23e69132e01db8cce43b 100644
--- a/linden/indra/newview/llvoavatar.cpp
+++ b/linden/indra/newview/llvoavatar.cpp
@@ -124,12 +124,13 @@
 #include "llgesturemgr.h" //needed to trigger the voice gesticulations
 #include "llvoicevisualizer.h" 
 #include "llvoiceclient.h"
+#include "llsdserialize.h" // client resolver
 
 LLXmlTree LLVOAvatar::sXMLTree;
 LLXmlTree LLVOAvatar::sSkeletonXMLTree;
 LLVOAvatarSkeletonInfo* LLVOAvatar::sSkeletonInfo = NULL;
 LLVOAvatarInfo* 		LLVOAvatar::sAvatarInfo = NULL;
-
+LLSD LLVOAvatar::sClientResolutionList;
 BOOL gDebugAvatarRotation = FALSE;
 S32 LLVOAvatar::sFreezeCounter = 0 ;
 
@@ -1483,6 +1484,10 @@ void LLVOAvatar::initClass()
 	{
 		llerrs << "Error parsing skeleton node in avatar XML file: " << skeleton_path << llendl;
 	}
+
+	{
+		loadClientTags();
+	}
 }
 
 
@@ -3074,6 +3079,230 @@ void LLVOAvatar::idleUpdateWindEffect()
 		}
 	}
 }
+bool LLVOAvatar::updateClientTags()
+{
+	std::string client_list_filename = gDirUtilp->getExpandedFilename(LL_PATH_USER_SETTINGS, "client_list.xml");
+//Imprudence FIXME provide own ressource
+	LLSD response = LLHTTPClient::blockingGet("http://www.modularsystems.sl/app/client_tags/client_list.xml");
+	if(response.has("body"))
+	{
+		const LLSD &client_list = response["body"];
+
+		if(client_list.has("isComplete"))
+		{
+			llofstream export_file;
+			export_file.open(client_list_filename);
+			LLSDSerialize::toPrettyXML(client_list, export_file);
+			export_file.close();
+			return true;
+		}
+	}
+	return false;
+}
+
+bool LLVOAvatar::loadClientTags()
+{
+	std::string client_list_filename = gDirUtilp->getExpandedFilename(LL_PATH_USER_SETTINGS, "client_list.xml");
+
+	if(!LLFile::isfile(client_list_filename))
+	{
+		client_list_filename = gDirUtilp->getExpandedFilename(LL_PATH_APP_SETTINGS, "client_list.xml");
+	}
+
+	if(LLFile::isfile(client_list_filename))
+	{
+		LLSD client_list;
+
+		llifstream importer(client_list_filename);
+		LLSDSerialize::fromXMLDocument(client_list, importer);
+		if(client_list.has("isComplete"))
+		{
+			sClientResolutionList = client_list;
+		}else
+		{
+			return false;
+		}
+	}else
+	{
+		return false;
+	}
+
+	for (std::vector<LLCharacter*>::iterator iter = LLCharacter::sInstances.begin();
+	iter != LLCharacter::sInstances.end(); ++iter)
+	{
+		LLVOAvatar* avatarp = (LLVOAvatar*) *iter;
+		if(avatarp)
+		{
+			LLVector3 root_pos_last = avatarp->mRoot.getWorldPosition();
+			avatarp->idleUpdateNameTag(root_pos_last);
+		}
+	}
+	return true;
+}
+
+void LLVOAvatar::resolveClient(LLColor4& avatar_name_color, std::string& client, LLVOAvatar* avatar)
+{
+	LLUUID idx = avatar->getTE(0)->getID();
+	if(LLVOAvatar::sClientResolutionList.has("isComplete") 
+		&& LLVOAvatar::sClientResolutionList.has(idx.asString()))
+	{
+		LLSD cllsd = LLVOAvatar::sClientResolutionList[idx.asString()];
+		client = cllsd["name"].asString();
+		LLColor4 colour;
+		colour.setValue(cllsd["color"]);
+		avatar_name_color += colour;
+		avatar_name_color *= 1.0/(cllsd["multiple"].asReal()+1.0f);
+	}
+	else
+	{	
+		if(idx == LLUUID("496d7072-7564-656e-6365-20726f636b73"))//Imprudence FIXME: example 
+		{
+			avatar_name_color += LLColor4(0.6f,0.8f,1.0f);//Imprudence
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "Imprudence";
+		}else if(idx == LLUUID("2a9a406c-f448-68f2-4e38-878f8c46c190"))
+		{
+			avatar_name_color += LLColor4(1.0f,0.9f,0.7f);//Meerkat
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "Meerkat";
+		}else if(idx == LLUUID("ccda2b3b-e72c-a112-e126-fee238b67218"))
+		{
+			avatar_name_color += LLColor4::green;//emerald
+			avatar_name_color += LLColor4::green;
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "Emerald";
+		}else if(idx == LLUUID("c252d89d-6f7c-7d90-f430-d140d2e3fbbe"))
+		{
+			avatar_name_color += LLColor4::red;//vlife jcool410
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "VLife";
+		}else if(idx == LLUUID("adcbe893-7643-fd12-f61c-0b39717e2e32"))
+		{
+			avatar_name_color += LLColor4::pink;//tyk3n
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "tyk3n";
+		}else if(idx == LLUUID("f3fd74a6-fee7-4b2f-93ae-ddcb5991da04") || idx == LLUUID("77662f23-c77a-9b4d-5558-26b757b2144c"))
+		{
+			avatar_name_color += (LLColor4::purple);//psl
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "PSL";
+		}else if(idx == LLUUID("5aa5c70d-d787-571b-0495-4fc1bdef1500"))
+		{
+			avatar_name_color += LLColor4::red;//lordgreg
+			avatar_name_color += LLColor4::red;
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "LGG proxy";
+		}else if(idx == LLUUID("8183e823-c443-2142-6eb6-2ab763d4f81c"))
+		{
+			avatar_name_color += LLColor4::blue;//day oh
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "Day Oh proxy";
+		}else if(idx == LLUUID("e52d21f7-3c8b-819f-a3db-65c432295dac") || idx == LLUUID("0f6723d2-5b23-6b58-08ab-308112b33786"))
+		{
+			avatar_name_color += LLColor4::cyan;//cryolife
+			avatar_name_color += LLColor4::cyan;
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "CryoLife";
+		}else if(idx == LLUUID("0bcd5f5d-a4ce-9ea4-f9e8-15132653b3d8"))
+		{
+			avatar_name_color += LLColor4::pink;//moy
+			avatar_name_color += LLColor4::pink;//moy
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "MoyMix";
+		}else if(idx == LLUUID("f5a48821-9a98-d09e-8d6a-50cc08ba9a47"))
+		{
+			avatar_name_color += LLColor4::yellow;//neil
+			avatar_name_color += LLColor4::yellow;//neil
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "NeilLife";
+		}else if(idx == LLUUID("2c9c1e0b-e5d1-263e-16b1-7fc6d169f3d6"))
+		{
+			avatar_name_color += LLColor4(0.0f,1.0f,1.0f);
+			avatar_name_color = avatar_name_color * 0.5;//phox
+			client = "PhoxSL";
+		}else if(idx == LLUUID("c5b570ca-bb7e-3c81-afd1-f62646b20014") || idx == LLUUID("7c4d47a3-0c51-04d1-fa47-e4f3ac12f59b"))
+		{
+			avatar_name_color += LLColor4::white;
+			avatar_name_color += LLColor4::white;
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "Kung Fu";
+		}else if(idx == LLUUID("9422e9d7-7b11-83e4-6262-4a8db4716a3b"))
+		{
+			avatar_name_color += LLColor4::magenta;
+			avatar_name_color += LLColor4::magenta;
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "BetaLife";
+		/*}else if(idx == LLUUID("872c0005-3095-0967-866d-11cd71115c22"))
+		{
+			avatar_name_color += LLColor4::green;//SimFed Poland
+			avatar_name_color += LLColor4::blue;//SimFed Poland
+			avatar_name_color += LLColor4::blue;//SimFed Poland
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "<-- Fag";
+		}*/ // no smoking.
+	
+			/*else if(idx == LLUUID("3ab7e2fa-9572-ef36-1a30-d855dbea4f92") || //wat
+					idx == LLUUID("11ad2452-ce54-8d65-7c23-05589b59f516") ||//wat.
+					idx == LLUUID("e734563e-1c31-2a35-3ed5-8552c807439f") ||//wat.
+					idx == LLUUID("58a8b7ec-1455-7162-5d96-d3c3ead2ed71") ||//wat
+					idx == LLUUID("841ef25b-3b90-caf9-ea3d-5649e755db65")//wat -.-
+					)
+		{
+			avatar_name_color += LLColor4(0.0f,0.5f,1.0f); //don't know that.
+			avatar_name_color = avatar_name_color * 0.5;   //but: no actual source - no detection.
+			client = "VerticalLife";
+	
+		*/
+		}else if(idx == LLUUID("4e8dcf80-336b-b1d8-ef3e-08dacf015a0f"))
+		{
+			avatar_name_color += LLColor4::blue; //Sapphire
+			avatar_name_color += LLColor4::blue; //Sapphire
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "Sapphire";
+		}else if(idx == LLUUID("ffce04ff-5303-4909-a044-d37af7ab0b0e"))
+		{
+			avatar_name_color += LLColor4::orange; //corgiVision
+			avatar_name_color = avatar_name_color * (F32)0.75;
+			client = "Corgi";
+		}else if(idx == LLUUID("ccb509cf-cc69-e569-38f1-5086c687afd1"))
+		{
+			avatar_name_color += LLColor4::red; //Ruby
+			avatar_name_color += LLColor4::purple; //Ruby
+			avatar_name_color = avatar_name_color * (F32)0.333333333333;
+			client = "Ruby";
+		}else if(idx == LLUUID("1c29480c-c608-df87-28bb-964fb64c5366"))
+		{
+			avatar_name_color += LLColor4::yellow9;
+			avatar_name_color += LLColor4::yellow9;
+			avatar_name_color *= (F32)0.333333333333;
+			client = "Gemini";
+		}
+	}
+	if(client.empty())
+	{
+		LLPointer<LLViewerImage> image_point = gImageList.getImage(idx, MIPMAP_YES, IMMEDIATE_NO);
+		if(image_point.notNull() && image_point->isMissingAsset())
+		{
+			avatar_name_color += LLColor4::grey;//anomalous
+			avatar_name_color = avatar_name_color * 0.5;
+			client = "Invalid";
+		}
+	}
+	if(avatar->getTE(5)->getID() != avatar->getTE(6)->getID() && client != "")
+	{
+		client = "Failure";
+		avatar_name_color = LLColor4::grey;
+	}
+	if(client.empty() && LLVOAvatar::sClientResolutionList.has("default"))
+	{
+		LLSD cllsd = LLVOAvatar::sClientResolutionList["default"];
+		client = cllsd["name"].asString();
+		LLColor4 colour;
+		colour.setValue(cllsd["color"]);
+		avatar_name_color += colour;
+		avatar_name_color *= 1.0/(cllsd["multiple"].asReal()+1.0f);
+	}
+}
 
 void LLVOAvatar::idleUpdateNameTag(const LLVector3& root_pos_last)
 {
@@ -3119,6 +3348,8 @@ void LLVOAvatar::idleUpdateNameTag(const LLVector3& root_pos_last)
 			new_name = TRUE;
 		}
 
+		std::string client;
+
 		// First Calculate Alpha
 		// If alpha > 0, create mNameText if necessary, otherwise delete it
 		{
@@ -3159,6 +3390,11 @@ void LLVOAvatar::idleUpdateNameTag(const LLVector3& root_pos_last)
 				}
 				
 				LLColor4 avatar_name_color = gColors.getColor( "AvatarNameColor" );
+				if(!mIsSelf) //don't know your own client ?
+				{
+					new_name = TRUE; //lol or see the last client used 
+					resolveClient(avatar_name_color,client, this);
+				}
 				avatar_name_color.setAlpha(alpha);
 				mNameText->setColor(avatar_name_color);
 				
@@ -3233,8 +3469,8 @@ void LLVOAvatar::idleUpdateNameTag(const LLVector3& root_pos_last)
 				line += " ";
 				line += lastname->getString();
 				BOOL need_comma = FALSE;
-
-				if (is_away || is_muted || is_busy)
+				bool show_client = client.length() != 0 && gSavedSettings.getBOOL("ShowClientNameTag");
+				if (is_away || is_muted || is_busy|| show_client)
 				{
 					line += " (";
 					if (is_away)
@@ -3260,6 +3496,15 @@ void LLVOAvatar::idleUpdateNameTag(const LLVector3& root_pos_last)
 						line += "Muted";
 						need_comma = TRUE;
 					}
+					if (show_client)
+					{
+						if (need_comma)
+						{
+							line += ", ";
+						}
+						line += client;
+						need_comma = TRUE;
+					}
 					line += ")";
 				}
 				if (is_appearance)
diff --git a/linden/indra/newview/llvoavatar.h b/linden/indra/newview/llvoavatar.h
index 9806ceb17b4c5096b4b24b3d7e0faa07af528981..b2fc98deaec62e9a59989c0726ca80a21f2f7bf4 100644
--- a/linden/indra/newview/llvoavatar.h
+++ b/linden/indra/newview/llvoavatar.h
@@ -864,6 +864,9 @@ public:
 	//--------------------------------------------------------------------
 	// static members
 	//--------------------------------------------------------------------
+	static bool updateClientTags();
+	static bool loadClientTags();
+
 	static S32		sMaxVisible;
 	static F32		sRenderDistance; //distance at which avatars will render (affected by control "RenderAvatarMaxVisible")
 	static S32		sCurJoint;
@@ -927,6 +930,10 @@ public:
 	LLTexLayerSet*		mEyesLayerSet;
 	LLTexLayerSet*		mSkirtLayerSet;
 
+	static LLSD sClientResolutionList;
+
+	static void resolveClient(LLColor4& avatar_name_color, std::string& client, LLVOAvatar* avatar);
+	friend class LLFloaterAvatarList;
 
 protected:
 	LLPointer<LLHUDEffectSpiral> mBeam;
diff --git a/linden/indra/newview/llworld.h b/linden/indra/newview/llworld.h
index 460809af84f6af502da415a99c2c489726a5eee6..56ea2907a91a25ec0367d18accdefc07dc3866a2 100644
--- a/linden/indra/newview/llworld.h
+++ b/linden/indra/newview/llworld.h
@@ -152,6 +152,7 @@ public:
 public:
 	typedef std::list<LLViewerRegion*> region_list_t;
 	const region_list_t& getRegionList() const { return mActiveRegionList; }
+	region_list_t	mActiveRegionList;
 
 	// Returns lists of avatar IDs and their world-space positions within a given distance of a point.
 	// All arguments are optional. Given containers will be emptied and then filled.
@@ -162,7 +163,6 @@ public:
 		const LLVector3d& relative_to = LLVector3d(), F32 radius = FLT_MAX) const;
 
 private:
-	region_list_t	mActiveRegionList;
 	region_list_t	mRegionList;
 	region_list_t	mVisibleRegionList;
 	region_list_t	mCulledRegionList;
diff --git a/linden/indra/newview/pipeline.cpp b/linden/indra/newview/pipeline.cpp
index 87b810cca1437ff8170a9c0ab161022e3b4a4960..2c064524144a17d84e0d1bce5d9b415c6b859454 100644
--- a/linden/indra/newview/pipeline.cpp
+++ b/linden/indra/newview/pipeline.cpp
@@ -78,6 +78,7 @@
 #include "llviewerimagelist.h"
 #include "llviewerobject.h"
 #include "llviewerobjectlist.h"
+#include "llviewerpartsource.h"
 #include "llviewerparcelmgr.h"
 #include "llviewerregion.h" // for audio debugging.
 #include "llviewerwindow.h" // For getSpinAxis
@@ -92,6 +93,7 @@
 #include "llvopartgroup.h"
 #include "llworld.h"
 #include "llcubemap.h"
+#include "llfloateravatarlist.h"
 #include "lldebugmessagebox.h"
 #include "llviewershadermgr.h"
 #include "llviewerjoystick.h"
@@ -2009,6 +2011,29 @@ void renderSoundHighlights(LLDrawable* drawablep)
 	}
 }
 
+/**
+ * @brief Add particle sources to avatar list
+ * This tells the avatar list floater who is emitting particles
+ */
+
+void addParticleSourcesToList(LLDrawable *drawablep)
+{
+	if ( LLFloaterAvatarList::getInstance() )
+	{
+		LLViewerObject *vobj = drawablep->getVObj();
+		if (vobj && vobj->isParticleSource())
+		{
+			LLUUID id = vobj->mPartSourcep->getOwnerUUID();
+		
+			LLAvatarListEntry *ent = LLFloaterAvatarList::getInstance()->getAvatarEntry(id);
+			if ( NULL != ent )
+			{
+				ent->setActivity(ACTIVITY_PARTICLES);
+			}
+		}
+	}
+}
+
 void LLPipeline::postSort(LLCamera& camera)
 {
 	LLMemType mt(LLMemType::MTYPE_PIPELINE);
@@ -2109,6 +2134,8 @@ void LLPipeline::postSort(LLCamera& camera)
 		std::sort(sCull->beginAlphaGroups(), sCull->endAlphaGroups(), LLSpatialGroup::CompareDepthGreater());
 	}
 
+	forAllVisibleDrawables(addParticleSourcesToList);
+
 	// only render if the flag is set. The flag is only set if we are in edit mode or the toggle is set in the menus
 	if (gSavedSettings.getBOOL("BeaconsEnabled"))
 	{
@@ -2157,6 +2184,25 @@ void LLPipeline::postSort(LLCamera& camera)
 		}
 	}
 
+	// Avatar list support
+	if (LLFloaterAvatarList::getInstance() && gAudiop )
+	{
+		LLAudioEngine::source_map::iterator iter;
+		for (iter = gAudiop->mAllSources.begin(); iter != gAudiop->mAllSources.end(); ++iter)
+		{
+			LLAudioSource *sourcep = iter->second;
+			LLUUID uuid = sourcep->getOwnerID();
+			LLAvatarListEntry *ent = LLFloaterAvatarList::getInstance()->getAvatarEntry(uuid);
+			if ( ent )
+			{
+				if ( ent ->getActivity() != ACTIVITY_TYPING)//typing sound, eh ?
+				{
+					ent->setActivity(ACTIVITY_SOUND);
+				}
+			}
+		}
+	}
+
 	// If managing your telehub, draw beacons at telehub and currently selected spawnpoint.
 	if (LLFloaterTelehub::renderBeacons())
 	{
diff --git a/linden/indra/newview/skins/default/xui/en-us/alerts.xml b/linden/indra/newview/skins/default/xui/en-us/alerts.xml
index 42d9782dbb61968fe60e245466ddf0bf98369a10..ec0d56dcf2d7aa4c91eff5520c74e16d718c76c1 100644
--- a/linden/indra/newview/skins/default/xui/en-us/alerts.xml
+++ b/linden/indra/newview/skins/default/xui/en-us/alerts.xml
@@ -1442,7 +1442,24 @@ chat, or interact with the world.
 			Cancel
 		</option>
 	</alert>
-	<alert modal="true" name="EjectAvatar">
+  <alert modal="true" name="AvatarListFreezeAvatars">
+    <message name="message">
+      Freeze these avatars?
+      [NAMES]
+      They will temporarily be unable to move,
+      chat, or interact with the world.
+    </message>
+    <option name="Freeze">
+      Freeze
+    </option>
+    <option name="Unfreeze">
+      Unfreeze
+    </option>
+    <option name="Cancel">
+      Cancel
+    </option>
+  </alert>
+  <alert modal="true" name="EjectAvatar">
 		<message name="message">
 			Eject this avatar from your land?
 		</message>
@@ -1492,6 +1509,147 @@ chat, or interact with the world.
             Cancel
         </option>
     </alert>
+    
+    <alert modal="true" name="AvatarListEjectAvatars">
+	    <message name="message">
+		    Eject these avatars from your land?
+		    [NAMES]
+	    </message>
+	    <option name="Eject">
+		    Eject
+	    </option>
+	    <option name="EjectandBan">
+		    Eject and Ban
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    <alert modal="true" name="AvatarListEjectAvatarsFromEstate">
+	    <message name="message">
+		    Eject these avatars from this estate?
+		    [NAMES]
+	    </message>
+	    <option name="Eject">
+		    Eject
+	    </option>
+	    <option name="EjectandBan">
+		    Eject and Ban
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    
+    <alert modal="true" name="AvatarListMuteAvatars">
+	    <message name="message">
+		    Mute these avatars?
+		    [NAMES]
+	    </message>
+	    <option name="Mute">
+		    Mute
+	    </option>
+	    <option name="Unmute">
+		    Unmute
+	    </option>		
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    <alert modal="true" name="AvatarListEjectAvatars">
+	    <message name="message">
+		    Eject these avatars from your land?
+		    [NAMES]
+	    </message>
+	    <option name="Eject">
+		    Eject
+	    </option>
+	    <option name="EjectandBan">
+		    Eject and Ban
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    <alert modal="true" name="AvatarListEjectAvatarsFromEstate">
+	    <message name="message">
+		    Eject these avatars from this estate?
+		    [NAMES]
+	    </message>
+	    <option name="Eject">
+		    Eject
+	    </option>
+	    <option name="EjectandBan">
+		    Eject and Ban
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    
+    <alert modal="true" name="AvatarListMuteAvatars">
+	    <message name="message">
+		    Mute these avatars?
+		    [NAMES]
+	    </message>
+	    <option name="Mute">
+		    Mute
+	    </option>
+	    <option name="Unmute">
+		    Unmute
+	    </option>		
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    
+    <alert modal="true" name="AvatarListEjectAvatars">
+	    <message name="message">
+		    Eject these avatars from your land?
+		    [NAMES]
+	    </message>
+	    <option name="Eject">
+		    Eject
+	    </option>
+	    <option name="EjectandBan">
+		    Eject and Ban
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    <alert modal="true" name="AvatarListEjectAvatarsFromEstate">
+	    <message name="message">
+		    Eject these avatars from this estate?
+		    [NAMES]
+	    </message>
+	    <option name="Eject">
+		    Eject
+	    </option>
+	    <option name="EjectandBan">
+		    Eject and Ban
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+    
+    <alert modal="true" name="AvatarListMuteAvatars">
+	    <message name="message">
+		    Mute these avatars?
+		    [NAMES]
+	    </message>
+	    <option name="Mute">
+		    Mute
+	    </option>
+	    <option name="Unmute">
+		    Unmute
+	    </option>
+	    <option name="Cancel">
+		    Cancel
+	    </option>
+    </alert>
+
     <alert modal="true" name="InvalidUUID">
 		<message name="message">
 			Not a valid UUID.
diff --git a/linden/indra/newview/skins/default/xui/en-us/floater_avatar_scanner.xml b/linden/indra/newview/skins/default/xui/en-us/floater_avatar_scanner.xml
new file mode 100644
index 0000000000000000000000000000000000000000..adc553265c25729b7d51039941e3c2c91157d90c
--- /dev/null
+++ b/linden/indra/newview/skins/default/xui/en-us/floater_avatar_scanner.xml
@@ -0,0 +1,396 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<floater
+	name="avatar list"
+	title="Avatar List"
+	can_resize="true"
+	can_minimize="true"
+	can_close="true"
+	can_drag_on_left="false"
+	rect_control="FloaterAvatarListRect"
+	min_width="400"
+	min_height="300"
+	>
+	<!-- <text
+		  name="help_label"
+		  bottom="-30"
+		  left="15"
+		  font="SansSerifSmall"
+		  follows="top|left"
+		  >
+	</text> -->
+	
+	<scroll_list
+		    name="avatar_list"
+		    left="10"
+		    right="-10"
+		    top="-20"
+		    bottom="140"
+		    column_padding="0"
+		    can_resize="true"
+		    follows="left|top|bottom|right"
+		    draw_heading="true"
+		    multi_select="true"
+		    search_column="1"
+		    tool_tip="Hold shift or control while clicking to select multiple avatars"
+		    >
+		<!-- Icons relating to the avatar, currently: tracking, and marked -->
+		<column name="avatar_icon" label="Icon" width="20" />
+		<column name="avatar_name" label="Name" dynamicwidth="true" />
+		<column name="distance" label="Distance" width="70"/>
+		<column name="age" label="Age" width="50"/>
+		<!-- <column name="payment_data" label="Payment" width="80"/> -->
+		<!-- TrustNet Score -->
+    <!-- <column name="score" label="Score" width="60"/> -->
+		<!-- Payment data icons -->
+		<column name="payment_data" label="" width="20" />
+		<!-- What the avatar is doing: producing sounds, rezzing, particles, etc -->
+		<column name="activity" label="" width="20" />
+    <column name="client" label="Client" dynamicwidth="true" />
+	</scroll_list>
+	
+	<tab_container border="false" bottom_delta="-130" height="120" left="6" mouse_opaque="false"
+		       name="actions_tab_container" tab_position="top" follows="left|right|bottom">
+		<panel border="true" bottom_delta="-130" follows="left|top|right|bottom" height="255"
+		       label="Avatar" left="1" mouse_opaque="true"
+		     name="actions_tab" width="398">
+			<!-- upper row -->
+			<button
+			       name="profile_btn"
+			       label="Profile"
+			       tool_tip="Show picture, groups, and other information"
+			       left="10"
+			       bottom_delta="-190"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="im_btn"
+			       label="IM"
+			       tool_tip="Open Instant Message session"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			
+
+			<!--middle row -->
+			<button
+			       name="track_btn"
+			       label="Track"
+			       tool_tip="Track this avatar's position"
+			       left="10"
+			       bottom_delta="-24"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="mark_btn"
+			       label="Mark"
+			       tool_tip="Mark this avatar in the list"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="get_key_btn"
+			       label="Get Key"
+			       tool_tip="Copies avatar's key to the clipboard"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="teleport_btn"
+			       label="Teleport"
+			       tool_tip="Teleport to avatar's position"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />			
+			<!-- lower row-->
+			<button
+			       name="prev_in_list_btn"
+			       label="Prev"
+			       tool_tip="Focus camera on previous avatar in list"
+			       left="10"
+			       bottom_delta="-24"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="next_in_list_btn"
+			       label="Next"
+			       tool_tip="Focus camera on next avatar in list"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="prev_marked_btn"
+			       label="Prev Marked"
+			       tool_tip="Focus camera on previous marked avatar"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="next_marked_btn"
+			       label="Next Marked"
+			       tool_tip="Focus camera on next marked avatar"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+
+		</panel>
+		<panel border="true" bottom_delta="-130" follows="left|top|right|bottom" height="255"
+		       label="Moderation" left="1" mouse_opaque="true"
+		       name="land_tab" width="398">
+			
+			<!-- Upper row -->
+			<button
+			       name="freeze_btn"
+			       label="Freeze"
+			       tool_tip="Freeze the avatar, preventing it from moving"
+			       left="10"
+			       bottom_delta="-190"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="eject_btn"
+			       label="Eject"
+			       tool_tip="Eject the avatar from the parcel"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			
+			<button
+			       name="mute_btn"
+			       label="Mute"
+			       tool_tip="Mute this avatar"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			
+
+			<button
+			       name="ar_btn"
+			       label="AR"
+			       tool_tip="Report abuse on this avatar"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+
+			<!-- middle row -->
+			<button
+			       name="estate_eject_btn"
+			       label="Eject from estate"
+			       tool_tip="Eject this avatar from the estate"
+			       left="10"
+			       bottom_delta="-24"
+			       width="170"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="unmute_btn"
+			       label="Unmute"
+			       tool_tip="Unmute this avatar"
+			       left_delta="180"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="ban_btn"
+			       label="Ban"
+			       tool_tip="Ban this avatar from parcel"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<!-- lower row-->
+			<button
+			       name="estate_ban_btn"
+			       label="Ban from estate"
+			       tool_tip="Ban this avatar from the estate"
+			       left="10"
+			       bottom_delta="-24"
+			       width="170"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+		</panel>
+		
+		
+		<panel border="true" bottom_delta="-130" follows="left|top|right|bottom" height="255"
+		       label="Custom" left="1" mouse_opaque="true" 
+		     name="custom_tab" width="398">
+			<!--Custom tools, upper row-->
+			<button
+			       name="custom1_btn"
+			       label="Custom 1"
+			       tool_tip=""
+                   enabled="false"
+			       left="10"
+			       bottom_delta="-190"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="custom2_btn"
+			       label="Custom 2"
+			       tool_tip=""
+                   enabled="false"
+			       left="100"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="custom3_btn"
+			       label="Custom 3"
+			       tool_tip=""
+                   enabled="false"
+			       left="190"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="custom4_btn"
+			       label="Custom 4"
+			       tool_tip=""
+                   enabled="false"
+			       left="280"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<!-- Middle row -->
+			<button
+			       name="custom5_btn"
+			       label="Custom 5"
+			       tool_tip=""
+                   enabled="false"
+			       left="10"
+			       bottom_delta="-24"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="custom6_btn"
+			       label="Custom 6"
+			       tool_tip=""
+                   enabled="false"
+			       left_delta="90"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="custom7_btn"
+			       label="Custom 7"
+			       tool_tip=""
+                   enabled="false"
+			       left="190"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+			<button
+			       name="custom8_btn"
+			       label="Custom 8"
+			       tool_tip=""
+                   enabled="false"
+			       left="280"
+			       bottom_delta="0"
+			       width="80"
+			       height="20"
+			       font="SansSerifSmall"
+			       follows="bottom|left"
+			       />
+		</panel>
+		<panel border="true" bottom_delta="-150" follows="left|top|right|bottom" height="255"
+		       label="Options" left="1" mouse_opaque="true"
+		     name="options_tab" width="398">
+			<check_box height="16" label="Update"
+				   left="10" bottom_delta="-190" name="update_enabled_cb" 
+				   width="200" follows="bottom|left"
+				   hidden="false" mouse_opaque="true" font="SansSerifSmall"
+				   initial_value="true" enabled="true" radio_style="false" 
+				   tool_tip="Set whether the avatar list should update" />
+			
+			<check_box height="16" label="Get avatar info"
+				   left="20" bottom_delta="-21" name="fetch_avdata_enabled_cb" 
+				   width="200" follows="bottom|left"
+				   hidden="false" mouse_opaque="true" font="SansSerifSmall"
+				   initial_value="true" enabled="true" radio_style="false" 
+			   tool_tip="Set whether avatar information should be retrieved" />			
+		</panel>
+	</tab_container>
+
+</floater>
\ No newline at end of file
diff --git a/linden/indra/newview/skins/default/xui/en-us/menu_viewer.xml b/linden/indra/newview/skins/default/xui/en-us/menu_viewer.xml
index e085b21b216629a49c9c4af4833ea96255834629..39dafaa998580f3152d1d6b5b08f4af8e991f7e3 100644
--- a/linden/indra/newview/skins/default/xui/en-us/menu_viewer.xml
+++ b/linden/indra/newview/skins/default/xui/en-us/menu_viewer.xml
@@ -322,6 +322,10 @@
       <on_check control="ShowMiniMap" />
     </menu_item_check>
     <menu_item_separator />
+    <menu_item_check bottom="-65" enabled="true" height="19" hidden="false" label="Avatar List" left="0" mouse_opaque="true" name="Avatar List" width="211">
+      <on_click function="View.AvatarList" userdata="avatar list" />
+      <on_check function="View.CheckAvatarList" userdata="avatar list" />
+    </menu_item_check>
     <menu_item_check name="Statistics Bar" label="Statistics Bar"
                      shortcut="control|shift|1">
       <on_click function="ShowFloater" userdata="stat bar" />
diff --git a/linden/indra/newview/skins/default/xui/en-us/notify.xml b/linden/indra/newview/skins/default/xui/en-us/notify.xml
index 99fe75a16b32cd050310c59b71fb312cad647a7f..ea06339b2be0ddb4000249f5dda69bb523110568 100644
--- a/linden/indra/newview/skins/default/xui/en-us/notify.xml
+++ b/linden/indra/newview/skins/default/xui/en-us/notify.xml
@@ -918,6 +918,20 @@ You can find example sculpted textures in the inventory library.
 			You have begun playing media.  Media can set to play automatically in the preferences window under Audio / Video. Note that this can be a security risk for media sites you do not trust.
 		</message>
 	</notify>
+	<notify      name="QueryClientTags" tip="false">
+		<message name="message">
+			Would you like to have the client tag database automatically updated from modularsystems.sl?
+			This ensures that you have the latest information available regarding other clients.
+		</message>
+		<option name="Yes">
+			Yes
+		</option>
+		<option name="No">
+			No
+		</option>
+
+	</notify>
+	
 	<notify name="MaxListSelectMessage" tip="true">
 		<message name="message">
 			You may only select up to [MAX_SELECT] items
diff --git a/linden/indra/newview/skins/default/xui/en-us/panel_toolbar.xml b/linden/indra/newview/skins/default/xui/en-us/panel_toolbar.xml
index 9c57be09bc57e2301d8ba6f6ef8a21ca7f7e0d60..9101a6e15ff80ae46b8afc37c92f338dbcbe73fe 100644
--- a/linden/indra/newview/skins/default/xui/en-us/panel_toolbar.xml
+++ b/linden/indra/newview/skins/default/xui/en-us/panel_toolbar.xml
@@ -13,6 +13,14 @@
 	       image_overlay="icn_chatbar.tga" tool_tip="Show Chat Bar. (Enter)"
 	       width="50" auto_resize="false" follows="left|right" user_resize="false"/>
     <icon image_name="spacer24.tga" left_delta="2" width="2" height="2" follows="left|right" auto_resize="false" color="0,0,0,0"/>
+
+    <button bottom="0" font="SansSerif" height="24" label="Avatars" left="0"
+      name="avatar_list_btn" tool_tip="List of nearby avatars" width="50"
+       image_selected="toolbar_btn_selected.tga"
+       image_unselected="toolbar_btn_enabled.tga" scale_image="true"
+      follows="left|right" user_resize="false" />
+    <icon image_name="spacer24.tga" width="2" height="2" follows="left|right" auto_resize="false" color="0,0,0,0"/>
+    
      <flyout_button bottom="0" font="SansSerif" height="24" label="Communicate" left="0"
 	       name="communicate_btn" tool_tip="Communicate with your Friends and Groups."
 	       list_position="above"
-- 
1.5.6.5

